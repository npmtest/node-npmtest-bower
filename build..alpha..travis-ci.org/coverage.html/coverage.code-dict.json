{"/home/travis/build/npmtest/node-npmtest-bower/test.js":"/* istanbul instrument in package npmtest_bower */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bower/lib.npmtest_bower.js":"/* istanbul instrument in package npmtest_bower */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bower = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bower = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bower/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bower && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bower */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bower\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bower.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_bower.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bower.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_bower.__dirname +\n                    '/lib.npmtest_bower.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/index.js":"var commands = require('./commands');\nvar version = require('./version');\nvar abbreviations = require('./util/abbreviations')(commands);\n\nfunction clearRuntimeCache() {\n    // Note that in edge cases, some architecture components instance's\n    // in-memory cache might be skipped.\n    // If that's a problem, you should create and fresh instances instead.\n    var PackageRepository = require('./core/PackageRepository');\n    PackageRepository.clearRuntimeCache();\n}\n\nmodule.exports = {\n    version: version,\n    commands: commands,\n    config: require('./config')(),\n    abbreviations: abbreviations,\n    reset: clearRuntimeCache\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/commands/index.js":"var Q = require('q');\nvar Logger = require('bower-logger');\nvar config = require('../config');\n\n/**\n * Require commands only when called.\n *\n * Running `commandFactory(id)` is equivalent to `require(id)`. Both calls return\n * a command function. The difference is that `cmd = commandFactory()` and `cmd()`\n * return as soon as possible and load and execute the command asynchronously.\n */\nfunction commandFactory(id) {\n    function runApi() {\n        var command = require(id);\n        var commandArgs = [].slice.call(arguments);\n\n        return withLogger(function (logger) {\n            commandArgs.unshift(logger);\n\n            return command.apply(undefined, commandArgs);\n        });\n    }\n\n    function runFromArgv(argv) {\n        var commandArgs;\n        var command = require(id);\n\n        commandArgs = command.readOptions(argv);\n\n        return withLogger(function (logger) {\n            commandArgs.unshift(logger);\n\n            return command.apply(undefined, commandArgs);\n        });\n    }\n\n    function withLogger(func) {\n        var logger = new Logger();\n\n        Q.try(func, logger)\n        .done(function () {\n            config.restore();\n            var args = [].slice.call(arguments);\n            args.unshift('end');\n            logger.emit.apply(logger, args);\n        }, function (error) {\n            config.restore();\n            logger.emit('error', error);\n        });\n\n        return logger;\n    }\n\n    runApi.line = runFromArgv;\n\n    return runApi;\n}\n\n\nmodule.exports = {\n    cache: {\n        clean: commandFactory('./cache/clean'),\n        list: commandFactory('./cache/list'),\n    },\n    help: commandFactory('./help'),\n    home: commandFactory('./home'),\n    info: commandFactory('./info'),\n    init: commandFactory('./init'),\n    install: commandFactory('./install'),\n    link: commandFactory('./link'),\n    list: commandFactory('./list'),\n    login: commandFactory('./login'),\n    lookup: commandFactory('./lookup'),\n    prune: commandFactory('./prune'),\n    register: commandFactory('./register'),\n    search: commandFactory('./search'),\n    update: commandFactory('./update'),\n    uninstall: commandFactory('./uninstall'),\n    unregister: commandFactory('./unregister'),\n    version: commandFactory('./version')\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/q/q.js":"// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you don’t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Miller’s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-logger/lib/Logger.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar slice = Array.prototype.slice;\n\nfunction Logger() {\n    this._interceptors = [];\n    this._piped = [];\n}\n\nutil.inherits(Logger, EventEmitter);\n\nLogger.prototype.intercept = function (fn) {\n    this._interceptors.push(fn);\n    return this;\n};\n\nLogger.prototype.emit = function () {\n    var ret;\n    var args = slice.call(arguments);\n\n    // Run interceptors before\n    if (args[0] === 'log') {\n        this._interceptors.forEach(function (interceptor) {\n            interceptor.apply(this, args.slice(1));\n        });\n    }\n\n    ret = EventEmitter.prototype.emit.apply(this, args);\n\n    // Pipe\n    this._piped.forEach(function (emitter) {\n        emitter.emit.apply(emitter, args);\n    });\n\n    return ret;\n};\n\nLogger.prototype.pipe = function (emitter) {\n    this._piped.push(emitter);\n\n    return emitter;\n};\n\nLogger.prototype.geminate = function () {\n    var logger = new Logger();\n\n    logger.pipe(this);\n    return logger;\n};\n\nLogger.prototype.log = function (level, id, message, data) {\n    var log = {\n        level: level,\n        id: id,\n        message: message,\n        data: data || {}\n    };\n\n    // Emit log\n    this.emit('log', log);\n\n    return this;\n};\n\nLogger.prototype.prompt = function (prompts, callback) {\n    var fn;\n    var one;\n    var invalid;\n    var runned;\n    var error;\n    var validPrompts = Logger._validPrompts;\n\n    if (!Array.isArray(prompts)) {\n        prompts.name = 'prompt';\n        prompts = [prompts];\n        one = true;\n    }\n\n    // Validate prompt types\n    invalid = prompts.some(function (prompt) {\n        return validPrompts.indexOf(prompt.type) === -1;\n    });\n\n    if (invalid) {\n        error = new Error('Unknown prompt type');\n        error.code = 'ENOTSUP';\n        return callback(error);\n    }\n\n    fn = function (answers) {\n        // Run callback only once\n        if (runned) {\n            return;\n        }\n\n        // Trim answers automatically\n        Object.keys(answers).forEach(function (key) {\n            var value = answers[key];\n\n            if (typeof value === 'string') {\n                answers[key] = value.trim();\n            } else if (Array.isArray(value)) {\n                answers[key] = value.map(function (item) {\n                    if (typeof item === 'string') {\n                        return item.trim();\n                    }\n                });\n            }\n        });\n\n        runned = true;\n\n        // If only one prompt was requested, resolve with its answer\n        if (one) {\n            answers = answers.prompt;\n        }\n\n        callback(null, answers);\n    };\n\n    this.emit('prompt', prompts, fn);\n};\n\n// ------------------\n\nLogger._validPrompts = [\n    'input',\n    'confirm',\n    'password',\n    'checkbox'\n];\n\nLogger.LEVELS = {\n    'error': 5,\n    'conflict': 4,\n    'warn': 3,\n    'action': 2,\n    'info': 1,\n    'debug': 0\n};\n\n// Add helpful log methods\nObject.keys(Logger.LEVELS).forEach(function (level) {\n    Logger.prototype[level] = function (id, message, data) {\n        this.log(level, id, message, data);\n    };\n});\n\nmodule.exports = Logger;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/config.js":"var tty = require('tty');\nvar object = require('mout').object;\nvar bowerConfig = require('bower-config');\nvar Configstore = require('configstore');\n\nvar current;\n\nfunction defaultConfig(config) {\n    config = config || {};\n\n    return readCachedConfig(config.cwd || process.cwd(), config);\n}\n\nfunction readCachedConfig(cwd, overwrites) {\n    current = bowerConfig.create(cwd).load(overwrites);\n\n    var config = current.toObject();\n\n    var configstore = new Configstore('bower-github').all;\n\n    object.mixIn(config, configstore);\n\n    // If interactive is auto (null), guess its value\n    if (config.interactive == null) {\n        config.interactive = (\n            process.bin === 'bower' &&\n            tty.isatty(1) &&\n            !process.env.CI\n        );\n    }\n\n    // Merge common CLI options into the config\n    if (process.bin === 'bower') {\n        var cli = require('./util/cli');\n\n        object.mixIn(config, cli.readOptions({\n            force: { type: Boolean, shorthand: 'f' },\n            offline: { type: Boolean, shorthand: 'o' },\n            verbose: { type: Boolean, shorthand: 'V' },\n            quiet: { type: Boolean, shorthand: 'q' },\n            loglevel: { type: String, shorthand: 'l' },\n            json: { type: Boolean, shorthand: 'j' },\n            silent: { type: Boolean, shorthand: 's' }\n        }));\n    }\n\n    return config;\n}\n\nfunction restoreConfig() {\n    if (current) {\n        current.restore();\n    }\n}\n\nfunction resetCache() {\n    restoreConfig();\n    current = undefined;\n}\n\nmodule.exports = defaultConfig;\nmodule.exports.restore = restoreConfig;\nmodule.exports.reset = resetCache;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/index.js":"/**@license\n * mout v0.11.1 | http://moutjs.com | MIT license\n */\n\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'VERSION' : '0.11.1',\n    'array' : require('./array'),\n    'collection' : require('./collection'),\n    'date' : require('./date'),\n    'function' : require('./function'),\n    'lang' : require('./lang'),\n    'math' : require('./math'),\n    'number' : require('./number'),\n    'object' : require('./object'),\n    'queryString' : require('./queryString'),\n    'random' : require('./random'),\n    'string' : require('./string'),\n    'time' : require('./time'),\n    'fn' : require('./function')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'append' : require('./array/append'),\n    'collect' : require('./array/collect'),\n    'combine' : require('./array/combine'),\n    'compact' : require('./array/compact'),\n    'contains' : require('./array/contains'),\n    'difference' : require('./array/difference'),\n    'equals' : require('./array/equals'),\n    'every' : require('./array/every'),\n    'filter' : require('./array/filter'),\n    'find' : require('./array/find'),\n    'findIndex' : require('./array/findIndex'),\n    'findLast' : require('./array/findLast'),\n    'findLastIndex' : require('./array/findLastIndex'),\n    'flatten' : require('./array/flatten'),\n    'forEach' : require('./array/forEach'),\n    'groupBy' : require('./array/groupBy'),\n    'indexOf' : require('./array/indexOf'),\n    'insert' : require('./array/insert'),\n    'intersection' : require('./array/intersection'),\n    'invoke' : require('./array/invoke'),\n    'join' : require('./array/join'),\n    'last' : require('./array/last'),\n    'lastIndexOf' : require('./array/lastIndexOf'),\n    'map' : require('./array/map'),\n    'max' : require('./array/max'),\n    'min' : require('./array/min'),\n    'pick' : require('./array/pick'),\n    'pluck' : require('./array/pluck'),\n    'range' : require('./array/range'),\n    'reduce' : require('./array/reduce'),\n    'reduceRight' : require('./array/reduceRight'),\n    'reject' : require('./array/reject'),\n    'remove' : require('./array/remove'),\n    'removeAll' : require('./array/removeAll'),\n    'reverse' : require('./array/reverse'),\n    'shuffle' : require('./array/shuffle'),\n    'slice' : require('./array/slice'),\n    'some' : require('./array/some'),\n    'sort' : require('./array/sort'),\n    'sortBy' : require('./array/sortBy'),\n    'split' : require('./array/split'),\n    'take' : require('./array/take'),\n    'toLookup' : require('./array/toLookup'),\n    'union' : require('./array/union'),\n    'unique' : require('./array/unique'),\n    'xor' : require('./array/xor'),\n    'zip' : require('./array/zip')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/append.js":"\n\n    /**\n     * Appends an array to the end of another.\n     * The first array will be modified.\n     */\n    function append(arr1, arr2) {\n        if (arr2 == null) {\n            return arr1;\n        }\n\n        var pad = arr1.length,\n            i = -1,\n            len = arr2.length;\n        while (++i < len) {\n            arr1[pad + i] = arr2[i];\n        }\n        return arr1;\n    }\n    module.exports = append;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/collect.js":"var append = require('./append');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Maps the items in the array and concatenates the result arrays.\n     */\n    function collect(arr, callback, thisObj){\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null) {\n            return results;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            var value = callback(arr[i], i, arr);\n            if (value != null) {\n                append(results, value);\n            }\n        }\n\n        return results;\n    }\n\n    module.exports = collect;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/makeIterator_.js":"var identity = require('./identity');\nvar prop = require('./prop');\nvar deepMatches = require('../object/deepMatches');\n\n    /**\n     * Converts argument into a valid iterator.\n     * Used internally on most array/object/collection methods that receives a\n     * callback/iterator providing a shortcut syntax.\n     */\n    function makeIterator(src, thisObj){\n        if (src == null) {\n            return identity;\n        }\n        switch(typeof src) {\n            case 'function':\n                // function is the first to improve perf (most common case)\n                // also avoid using `Function#call` if not needed, which boosts\n                // perf a lot in some cases\n                return (typeof thisObj !== 'undefined')? function(val, i, arr){\n                    return src.call(thisObj, val, i, arr);\n                } : src;\n            case 'object':\n                return function(val){\n                    return deepMatches(val, src);\n                };\n            case 'string':\n            case 'number':\n                return prop(src);\n        }\n    }\n\n    module.exports = makeIterator;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/identity.js":"\n\n    /**\n     * Returns the first argument provided to it.\n     */\n    function identity(val){\n        return val;\n    }\n\n    module.exports = identity;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/prop.js":"\n\n    /**\n     * Returns a function that gets a property of the passed object\n     */\n    function prop(name){\n        return function(obj){\n            return obj[name];\n        };\n    }\n\n    module.exports = prop;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/deepMatches.js":"var forOwn = require('./forOwn');\nvar isArray = require('../lang/isArray');\n\n    function containsMatch(array, pattern) {\n        var i = -1, length = array.length;\n        while (++i < length) {\n            if (deepMatches(array[i], pattern)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function matchArray(target, pattern) {\n        var i = -1, patternLength = pattern.length;\n        while (++i < patternLength) {\n            if (!containsMatch(target, pattern[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function matchObject(target, pattern) {\n        var result = true;\n        forOwn(pattern, function(val, key) {\n            if (!deepMatches(target[key], val)) {\n                // Return false to break out of forOwn early\n                return (result = false);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Recursively check if the objects match.\n     */\n    function deepMatches(target, pattern){\n        if (target && typeof target === 'object') {\n            if (isArray(target) && isArray(pattern)) {\n                return matchArray(target, pattern);\n            } else {\n                return matchObject(target, pattern);\n            }\n        } else {\n            return target === pattern;\n        }\n    }\n\n    module.exports = deepMatches;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/forOwn.js":"var hasOwn = require('./hasOwn');\nvar forIn = require('./forIn');\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forOwn(obj, fn, thisObj){\n        forIn(obj, function(val, key){\n            if (hasOwn(obj, key)) {\n                return fn.call(thisObj, obj[key], key, obj);\n            }\n        });\n    }\n\n    module.exports = forOwn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/hasOwn.js":"\n\n    /**\n     * Safer Object.hasOwnProperty\n     */\n     function hasOwn(obj, prop){\n         return Object.prototype.hasOwnProperty.call(obj, prop);\n     }\n\n     module.exports = hasOwn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/forIn.js":"var hasOwn = require('./hasOwn');\n\n    var _hasDontEnumBug,\n        _dontEnums;\n\n    function checkDontEnum(){\n        _dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ];\n\n        _hasDontEnumBug = true;\n\n        for (var key in {'toString': null}) {\n            _hasDontEnumBug = false;\n        }\n    }\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forIn(obj, fn, thisObj){\n        var key, i = 0;\n        // no need to check if argument is a real object that way we can use\n        // it for arrays, functions, date, etc.\n\n        //post-pone check till needed\n        if (_hasDontEnumBug == null) checkDontEnum();\n\n        for (key in obj) {\n            if (exec(fn, obj, key, thisObj) === false) {\n                break;\n            }\n        }\n\n\n        if (_hasDontEnumBug) {\n            var ctor = obj.constructor,\n                isProto = !!ctor && obj === ctor.prototype;\n\n            while (key = _dontEnums[i++]) {\n                // For constructor, if it is a prototype object the constructor\n                // is always non-enumerable unless defined otherwise (and\n                // enumerated above).  For non-prototype objects, it will have\n                // to be defined on this object, since it cannot be defined on\n                // any prototype objects.\n                //\n                // For other [[DontEnum]] properties, check if the value is\n                // different than Object prototype value.\n                if (\n                    (key !== 'constructor' ||\n                        (!isProto && hasOwn(obj, key))) &&\n                    obj[key] !== Object.prototype[key]\n                ) {\n                    if (exec(fn, obj, key, thisObj) === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function exec(fn, obj, key, thisObj){\n        return fn.call(thisObj, obj[key], key, obj);\n    }\n\n    module.exports = forIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isArray.js":"var isKind = require('./isKind');\n    /**\n     */\n    var isArray = Array.isArray || function (val) {\n        return isKind(val, 'Array');\n    };\n    module.exports = isArray;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isKind.js":"var kindOf = require('./kindOf');\n    /**\n     * Check if value is from a specific \"kind\".\n     */\n    function isKind(val, kind){\n        return kindOf(val) === kind;\n    }\n    module.exports = isKind;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/kindOf.js":"\n\n    var _rKind = /^\\[object (.*)\\]$/,\n        _toString = Object.prototype.toString,\n        UNDEF;\n\n    /**\n     * Gets the \"kind\" of value. (e.g. \"String\", \"Number\", etc)\n     */\n    function kindOf(val) {\n        if (val === null) {\n            return 'Null';\n        } else if (val === UNDEF) {\n            return 'Undefined';\n        } else {\n            return _rKind.exec( _toString.call(val) )[1];\n        }\n    }\n    module.exports = kindOf;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/combine.js":"var indexOf = require('./indexOf');\n\n    /**\n     * Combines an array with all the items of another.\n     * Does not allow duplicates and is case and type sensitive.\n     */\n    function combine(arr1, arr2) {\n        if (arr2 == null) {\n            return arr1;\n        }\n\n        var i = -1, len = arr2.length;\n        while (++i < len) {\n            if (indexOf(arr1, arr2[i]) === -1) {\n                arr1.push(arr2[i]);\n            }\n        }\n\n        return arr1;\n    }\n    module.exports = combine;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/indexOf.js":"\n\n    /**\n     * Array.indexOf\n     */\n    function indexOf(arr, item, fromIndex) {\n        fromIndex = fromIndex || 0;\n        if (arr == null) {\n            return -1;\n        }\n\n        var len = arr.length,\n            i = fromIndex < 0 ? len + fromIndex : fromIndex;\n        while (i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if (arr[i] === item) {\n                return i;\n            }\n\n            i++;\n        }\n\n        return -1;\n    }\n\n    module.exports = indexOf;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/compact.js":"var filter = require('./filter');\n\n    /**\n     * Remove all null/undefined items from array.\n     */\n    function compact(arr) {\n        return filter(arr, function(val){\n            return (val != null);\n        });\n    }\n\n    module.exports = compact;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/filter.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array filter\n     */\n    function filter(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null) {\n            return results;\n        }\n\n        var i = -1, len = arr.length, value;\n        while (++i < len) {\n            value = arr[i];\n            if (callback(value, i, arr)) {\n                results.push(value);\n            }\n        }\n\n        return results;\n    }\n\n    module.exports = filter;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/contains.js":"var indexOf = require('./indexOf');\n\n    /**\n     * If array contains values.\n     */\n    function contains(arr, val) {\n        return indexOf(arr, val) !== -1;\n    }\n    module.exports = contains;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/difference.js":"var unique = require('./unique');\nvar filter = require('./filter');\nvar some = require('./some');\nvar contains = require('./contains');\nvar slice = require('./slice');\n\n\n    /**\n     * Return a new Array with elements that aren't present in the other Arrays.\n     */\n    function difference(arr) {\n        var arrs = slice(arguments, 1),\n            result = filter(unique(arr), function(needle){\n                return !some(arrs, function(haystack){\n                    return contains(haystack, needle);\n                });\n            });\n        return result;\n    }\n\n    module.exports = difference;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/unique.js":"var filter = require('./filter');\n\n    /**\n     * @return {array} Array of unique items\n     */\n    function unique(arr, compare){\n        compare = compare || isEqual;\n        return filter(arr, function(item, i, arr){\n            var n = arr.length;\n            while (++i < n) {\n                if ( compare(item, arr[i]) ) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    function isEqual(a, b){\n        return a === b;\n    }\n\n    module.exports = unique;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/some.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array some\n     */\n    function some(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = false;\n        if (arr == null) {\n            return result;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if ( callback(arr[i], i, arr) ) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    module.exports = some;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/slice.js":"\n\n    /**\n     * Create slice of source array or array-like object\n     */\n    function slice(arr, start, end){\n        var len = arr.length;\n\n        if (start == null) {\n            start = 0;\n        } else if (start < 0) {\n            start = Math.max(len + start, 0);\n        } else {\n            start = Math.min(start, len);\n        }\n\n        if (end == null) {\n            end = len;\n        } else if (end < 0) {\n            end = Math.max(len + end, 0);\n        } else {\n            end = Math.min(end, len);\n        }\n\n        var result = [];\n        while (start < end) {\n            result.push(arr[start++]);\n        }\n\n        return result;\n    }\n\n    module.exports = slice;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/equals.js":"var is = require('../lang/is');\nvar isArray = require('../lang/isArray');\nvar every = require('./every');\n\n    /**\n     * Compares if both arrays have the same elements\n     */\n    function equals(a, b, callback){\n        callback = callback || is;\n\n        if (!isArray(a) || !isArray(b)) {\n            return callback(a, b);\n        }\n\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        return every(a, makeCompare(callback), b);\n    }\n\n    function makeCompare(callback) {\n        return function(value, i) {\n            return i in this && callback(value, this[i]);\n        };\n    }\n\n    module.exports = equals;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/is.js":"\n\n    /**\n     * Check if both arguments are egal.\n     */\n    function is(x, y){\n        // implementation borrowed from harmony:egal spec\n        if (x === y) {\n          // 0 === -0, but they are not identical\n          return x !== 0 || 1 / x === 1 / y;\n        }\n\n        // NaN !== NaN, but they are identical.\n        // NaNs are the only non-reflexive value, i.e., if x !== x,\n        // then x is a NaN.\n        // isNaN is broken: it converts its argument to number, so\n        // isNaN(\"foo\") => true\n        return x !== x && y !== y;\n    }\n\n    module.exports = is;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/every.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array every\n     */\n    function every(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = true;\n        if (arr == null) {\n            return result;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if (!callback(arr[i], i, arr) ) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    module.exports = every;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/find.js":"var findIndex = require('./findIndex');\n\n    /**\n     * Returns first item that matches criteria\n     */\n    function find(arr, iterator, thisObj){\n        var idx = findIndex(arr, iterator, thisObj);\n        return idx >= 0? arr[idx] : void(0);\n    }\n\n    module.exports = find;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/findIndex.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Returns the index of the first item that matches criteria\n     */\n    function findIndex(arr, iterator, thisObj){\n        iterator = makeIterator(iterator, thisObj);\n        if (arr == null) {\n            return -1;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            if (iterator(arr[i], i, arr)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    module.exports = findIndex;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/findLast.js":"var findLastIndex = require('./findLastIndex');\n\n    /**\n     * Returns last item that matches criteria\n     */\n    function findLast(arr, iterator, thisObj){\n        var idx = findLastIndex(arr, iterator, thisObj);\n        return idx >= 0? arr[idx] : void(0);\n    }\n\n    module.exports = findLast;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/findLastIndex.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Returns the index of the last item that matches criteria\n     */\n    function findLastIndex(arr, iterator, thisObj){\n        iterator = makeIterator(iterator, thisObj);\n        if (arr == null) {\n            return -1;\n        }\n\n        var n = arr.length;\n        while (--n >= 0) {\n            if (iterator(arr[n], n, arr)) {\n                return n;\n            }\n        }\n\n        return -1;\n    }\n\n    module.exports = findLastIndex;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/flatten.js":"var isArray = require('../lang/isArray');\nvar append = require('./append');\n\n    /*\n     * Helper function to flatten to a destination array.\n     * Used to remove the need to create intermediate arrays while flattening.\n     */\n    function flattenTo(arr, result, level) {\n        if (level === 0) {\n            append(result, arr);\n            return result;\n        }\n\n        var value,\n            i = -1,\n            len = arr.length;\n        while (++i < len) {\n            value = arr[i];\n            if (isArray(value)) {\n                flattenTo(value, result, level - 1);\n            } else {\n                result.push(value);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Recursively flattens an array.\n     * A new array containing all the elements is returned.\n     * If level is specified, it will only flatten up to that level.\n     */\n    function flatten(arr, level) {\n        if (arr == null) {\n            return [];\n        }\n\n        level = level == null ? -1 : level;\n        return flattenTo(arr, [], level);\n    }\n\n    module.exports = flatten;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/forEach.js":"\n\n    /**\n     * Array forEach\n     */\n    function forEach(arr, callback, thisObj) {\n        if (arr == null) {\n            return;\n        }\n        var i = -1,\n            len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if ( callback.call(thisObj, arr[i], i, arr) === false ) {\n                break;\n            }\n        }\n    }\n\n    module.exports = forEach;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/groupBy.js":"var forEach = require('../array/forEach');\nvar identity = require('../function/identity');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Bucket the array values.\n     */\n    function groupBy(arr, categorize, thisObj) {\n        if (categorize) {\n            categorize = makeIterator(categorize, thisObj);\n        } else {\n            // Default to identity function.\n            categorize = identity;\n        }\n\n        var buckets = {};\n        forEach(arr, function(element) {\n            var bucket = categorize(element);\n            if (!(bucket in buckets)) {\n                buckets[bucket] = [];\n            }\n\n            buckets[bucket].push(element);\n        });\n\n        return buckets;\n    }\n\n    module.exports = groupBy;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/insert.js":"var difference = require('./difference');\nvar slice = require('./slice');\n\n    /**\n     * Insert item into array if not already present.\n     */\n    function insert(arr, rest_items) {\n        var diff = difference(slice(arguments, 1), arr);\n        if (diff.length) {\n            Array.prototype.push.apply(arr, diff);\n        }\n        return arr.length;\n    }\n    module.exports = insert;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/intersection.js":"var unique = require('./unique');\nvar filter = require('./filter');\nvar every = require('./every');\nvar contains = require('./contains');\nvar slice = require('./slice');\n\n\n    /**\n     * Return a new Array with elements common to all Arrays.\n     * - based on underscore.js implementation\n     */\n    function intersection(arr) {\n        var arrs = slice(arguments, 1),\n            result = filter(unique(arr), function(needle){\n                return every(arrs, function(haystack){\n                    return contains(haystack, needle);\n                });\n            });\n        return result;\n    }\n\n    module.exports = intersection;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/invoke.js":"var slice = require('./slice');\n\n    /**\n     * Call `methodName` on each item of the array passing custom arguments if\n     * needed.\n     */\n    function invoke(arr, methodName, var_args){\n        if (arr == null) {\n            return arr;\n        }\n\n        var args = slice(arguments, 2);\n        var i = -1, len = arr.length, value;\n        while (++i < len) {\n            value = arr[i];\n            value[methodName].apply(value, args);\n        }\n\n        return arr;\n    }\n\n    module.exports = invoke;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/join.js":"var filter = require('./filter');\n\n    function isValidString(val) {\n        return (val != null && val !== '');\n    }\n\n    /**\n     * Joins strings with the specified separator inserted between each value.\n     * Null values and empty strings will be excluded.\n     */\n    function join(items, separator) {\n        separator = separator || '';\n        return filter(items, isValidString).join(separator);\n    }\n\n    module.exports = join;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/last.js":"\n\n    /**\n     * Returns last element of array.\n     */\n    function last(arr){\n        if (arr == null || arr.length < 1) {\n            return undefined;\n        }\n\n        return arr[arr.length - 1];\n    }\n\n    module.exports = last;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/lastIndexOf.js":"\n\n    /**\n     * Array lastIndexOf\n     */\n    function lastIndexOf(arr, item, fromIndex) {\n        if (arr == null) {\n            return -1;\n        }\n\n        var len = arr.length;\n        fromIndex = (fromIndex == null || fromIndex >= len)? len - 1 : fromIndex;\n        fromIndex = (fromIndex < 0)? len + fromIndex : fromIndex;\n\n        while (fromIndex >= 0) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if (arr[fromIndex] === item) {\n                return fromIndex;\n            }\n            fromIndex--;\n        }\n\n        return -1;\n    }\n\n    module.exports = lastIndexOf;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/map.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array map\n     */\n    function map(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null){\n            return results;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            results[i] = callback(arr[i], i, arr);\n        }\n\n        return results;\n    }\n\n     module.exports = map;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/max.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Return maximum value inside array\n     */\n    function max(arr, iterator, thisObj){\n        if (arr == null || !arr.length) {\n            return Infinity;\n        } else if (arr.length && !iterator) {\n            return Math.max.apply(Math, arr);\n        } else {\n            iterator = makeIterator(iterator, thisObj);\n            var result,\n                compare = -Infinity,\n                value,\n                temp;\n\n            var i = -1, len = arr.length;\n            while (++i < len) {\n                value = arr[i];\n                temp = iterator(value, i, arr);\n                if (temp > compare) {\n                    compare = temp;\n                    result = value;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    module.exports = max;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/min.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Return minimum value inside array\n     */\n    function min(arr, iterator, thisObj){\n        if (arr == null || !arr.length) {\n            return -Infinity;\n        } else if (arr.length && !iterator) {\n            return Math.min.apply(Math, arr);\n        } else {\n            iterator = makeIterator(iterator, thisObj);\n            var result,\n                compare = Infinity,\n                value,\n                temp;\n\n            var i = -1, len = arr.length;\n            while (++i < len) {\n                value = arr[i];\n                temp = iterator(value, i, arr);\n                if (temp < compare) {\n                    compare = temp;\n                    result = value;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    module.exports = min;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/pick.js":"var randInt = require('../random/randInt');\n\n    /**\n     * Remove random item(s) from the Array and return it.\n     * Returns an Array of items if [nItems] is provided or a single item if\n     * it isn't specified.\n     */\n    function pick(arr, nItems){\n        if (nItems != null) {\n            var result = [];\n            if (nItems > 0 && arr && arr.length) {\n                nItems = nItems > arr.length? arr.length : nItems;\n                while (nItems--) {\n                    result.push( pickOne(arr) );\n                }\n            }\n            return result;\n        }\n        return (arr && arr.length)? pickOne(arr) : void(0);\n    }\n\n\n    function pickOne(arr){\n        var idx = randInt(0, arr.length - 1);\n        return arr.splice(idx, 1)[0];\n    }\n\n\n    module.exports = pick;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randInt.js":"var MIN_INT = require('../number/MIN_INT');\nvar MAX_INT = require('../number/MAX_INT');\nvar rand = require('./rand');\n\n    /**\n     * Gets random integer inside range or snap to min/max values.\n     */\n    function randInt(min, max){\n        min = min == null? MIN_INT : ~~min;\n        max = max == null? MAX_INT : ~~max;\n        // can't be max + 0.5 otherwise it will round up if `rand`\n        // returns `max` causing it to overflow range.\n        // -0.5 and + 0.49 are required to avoid bias caused by rounding\n        return Math.round( rand(min - 0.5, max + 0.499999999999) );\n    }\n\n    module.exports = randInt;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/MIN_INT.js":"/**\n * @constant Minimum 32-bit signed integer value (-2^31).\n */\n\n    module.exports = -2147483648;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/MAX_INT.js":"/**\n * @constant Maximum 32-bit signed integer value. (2^31 - 1)\n */\n\n    module.exports = 2147483647;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/rand.js":"var random = require('./random');\nvar MIN_INT = require('../number/MIN_INT');\nvar MAX_INT = require('../number/MAX_INT');\n\n    /**\n     * Returns random number inside range\n     */\n    function rand(min, max){\n        min = min == null? MIN_INT : min;\n        max = max == null? MAX_INT : max;\n        return min + (max - min) * random();\n    }\n\n    module.exports = rand;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/random.js":"\n\n    /**\n     * Just a wrapper to Math.random. No methods inside mout/random should call\n     * Math.random() directly so we can inject the pseudo-random number\n     * generator if needed (ie. in case we need a seeded random or a better\n     * algorithm than the native one)\n     */\n    function random(){\n        return random.get();\n    }\n\n    // we expose the method so it can be swapped if needed\n    random.get = Math.random;\n\n    module.exports = random;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/pluck.js":"var map = require('./map');\n\n    /**\n     * Extract a list of property values.\n     */\n    function pluck(arr, propName){\n        return map(arr, propName);\n    }\n\n    module.exports = pluck;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/range.js":"var countSteps = require('../math/countSteps');\n\n    /**\n     * Returns an Array of numbers inside range.\n     */\n    function range(start, stop, step) {\n        if (stop == null) {\n            stop = start;\n            start = 0;\n        }\n        step = step || 1;\n\n        var result = [],\n            nSteps = countSteps(stop - start, step),\n            i = start;\n\n        while (i <= stop) {\n            result.push(i);\n            i += step;\n        }\n\n        return result;\n    }\n\n    module.exports = range;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/countSteps.js":"\n    /**\n    * Count number of full steps.\n    */\n    function countSteps(val, step, overflow){\n        val = Math.floor(val / step);\n\n        if (overflow) {\n            return val % overflow;\n        }\n\n        return val;\n    }\n\n    module.exports = countSteps;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/reduce.js":"\n\n    /**\n     * Array reduce\n     */\n    function reduce(arr, fn, initVal) {\n        // check for args.length since initVal might be \"undefined\" see #gh-57\n        var hasInit = arguments.length > 2,\n            result = initVal;\n\n        if (arr == null || !arr.length) {\n            if (!hasInit) {\n                throw new Error('reduce of empty array with no initial value');\n            } else {\n                return initVal;\n            }\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            if (!hasInit) {\n                result = arr[i];\n                hasInit = true;\n            } else {\n                result = fn(result, arr[i], i, arr);\n            }\n        }\n\n        return result;\n    }\n\n    module.exports = reduce;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/reduceRight.js":"\n\n    /**\n     * Array reduceRight\n     */\n    function reduceRight(arr, fn, initVal) {\n        // check for args.length since initVal might be \"undefined\" see #gh-57\n        var hasInit = arguments.length > 2;\n\n        if (arr == null || !arr.length) {\n            if (hasInit) {\n                return initVal;\n            } else {\n                throw new Error('reduce of empty array with no initial value');\n            }\n        }\n\n        var i = arr.length, result = initVal, value;\n        while (--i >= 0) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            value = arr[i];\n            if (!hasInit) {\n                result = value;\n                hasInit = true;\n            } else {\n                result = fn(result, value, i, arr);\n            }\n        }\n        return result;\n    }\n\n    module.exports = reduceRight;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/reject.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array reject\n     */\n    function reject(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null) {\n            return results;\n        }\n\n        var i = -1, len = arr.length, value;\n        while (++i < len) {\n            value = arr[i];\n            if (!callback(value, i, arr)) {\n                results.push(value);\n            }\n        }\n\n        return results;\n    }\n\n    module.exports = reject;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/remove.js":"var indexOf = require('./indexOf');\n\n    /**\n     * Remove a single item from the array.\n     * (it won't remove duplicates, just a single item)\n     */\n    function remove(arr, item){\n        var idx = indexOf(arr, item);\n        if (idx !== -1) arr.splice(idx, 1);\n    }\n\n    module.exports = remove;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/removeAll.js":"var indexOf = require('./indexOf');\n\n    /**\n     * Remove all instances of an item from array.\n     */\n    function removeAll(arr, item){\n        var idx = indexOf(arr, item);\n        while (idx !== -1) {\n            arr.splice(idx, 1);\n            idx = indexOf(arr, item, idx);\n        }\n    }\n\n    module.exports = removeAll;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/reverse.js":"\n\n    /**\n     * Returns a copy of the array in reversed order.\n     */\n    function reverse(array) {\n        var copy = array.slice();\n        copy.reverse();\n        return copy;\n    }\n\n    module.exports = reverse;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/shuffle.js":"var randInt = require('../random/randInt');\n\n    /**\n     * Shuffle array items.\n     */\n    function shuffle(arr) {\n        var results = [],\n            rnd;\n        if (arr == null) {\n            return results;\n        }\n\n        var i = -1, len = arr.length, value;\n        while (++i < len) {\n            if (!i) {\n                results[0] = arr[0];\n            } else {\n                rnd = randInt(0, i);\n                results[i] = results[rnd];\n                results[rnd] = arr[i];\n            }\n        }\n\n        return results;\n    }\n\n    module.exports = shuffle;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/sort.js":"\n\n    /**\n     * Merge sort (http://en.wikipedia.org/wiki/Merge_sort)\n     */\n    function mergeSort(arr, compareFn) {\n        if (arr == null) {\n            return [];\n        } else if (arr.length < 2) {\n            return arr;\n        }\n\n        if (compareFn == null) {\n            compareFn = defaultCompare;\n        }\n\n        var mid, left, right;\n\n        mid   = ~~(arr.length / 2);\n        left  = mergeSort( arr.slice(0, mid), compareFn );\n        right = mergeSort( arr.slice(mid, arr.length), compareFn );\n\n        return merge(left, right, compareFn);\n    }\n\n    function defaultCompare(a, b) {\n        return a < b ? -1 : (a > b? 1 : 0);\n    }\n\n    function merge(left, right, compareFn) {\n        var result = [];\n\n        while (left.length && right.length) {\n            if (compareFn(left[0], right[0]) <= 0) {\n                // if 0 it should preserve same order (stable)\n                result.push(left.shift());\n            } else {\n                result.push(right.shift());\n            }\n        }\n\n        if (left.length) {\n            result.push.apply(result, left);\n        }\n\n        if (right.length) {\n            result.push.apply(result, right);\n        }\n\n        return result;\n    }\n\n    module.exports = mergeSort;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/sortBy.js":"var sort = require('./sort');\nvar makeIterator = require('../function/makeIterator_');\n\n    /*\n     * Sort array by the result of the callback\n     */\n    function sortBy(arr, callback, context){\n        callback = makeIterator(callback, context);\n\n        return sort(arr, function(a, b) {\n            a = callback(a);\n            b = callback(b);\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        });\n    }\n\n    module.exports = sortBy;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/split.js":"\n\n    /**\n     * Split array into a fixed number of segments.\n     */\n    function split(array, segments) {\n        segments = segments || 2;\n        var results = [];\n        if (array == null) {\n            return results;\n        }\n\n        var minLength = Math.floor(array.length / segments),\n            remainder = array.length % segments,\n            i = 0,\n            len = array.length,\n            segmentIndex = 0,\n            segmentLength;\n\n        while (i < len) {\n            segmentLength = minLength;\n            if (segmentIndex < remainder) {\n                segmentLength++;\n            }\n\n            results.push(array.slice(i, i + segmentLength));\n\n            segmentIndex++;\n            i += segmentLength;\n        }\n\n        return results;\n    }\n    module.exports = split;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/take.js":"\n\n    /**\n     * Iterates over a callback a set amount of times\n     * returning the results\n     */\n    function take(n, callback, thisObj){\n        var i = -1;\n        var arr = [];\n        if( !thisObj ){\n            while(++i < n){\n                arr[i] = callback(i, n);\n            }\n        } else {\n            while(++i < n){\n                arr[i] = callback.call(thisObj, i, n);\n            }\n        }\n        return arr;\n    }\n\n    module.exports = take;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/toLookup.js":"var isFunction = require('../lang/isFunction');\n\n    /**\n     * Creates an object that holds a lookup for the objects in the array.\n     */\n    function toLookup(arr, key) {\n        var result = {};\n        if (arr == null) {\n            return result;\n        }\n\n        var i = -1, len = arr.length, value;\n        if (isFunction(key)) {\n            while (++i < len) {\n                value = arr[i];\n                result[key(value)] = value;\n            }\n        } else {\n            while (++i < len) {\n                value = arr[i];\n                result[value[key]] = value;\n            }\n        }\n\n        return result;\n    }\n    module.exports = toLookup;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isFunction.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isFunction(val) {\n        return isKind(val, 'Function');\n    }\n    module.exports = isFunction;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/union.js":"var unique = require('./unique');\nvar append = require('./append');\n\n    /**\n     * Concat multiple arrays and remove duplicates\n     */\n    function union(arrs) {\n        var results = [];\n        var i = -1, len = arguments.length;\n        while (++i < len) {\n            append(results, arguments[i]);\n        }\n\n        return unique(results);\n    }\n\n    module.exports = union;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/xor.js":"var unique = require('./unique');\nvar filter = require('./filter');\nvar contains = require('./contains');\n\n\n    /**\n     * Exclusive OR. Returns items that are present in a single array.\n     * - like ptyhon's `symmetric_difference`\n     */\n    function xor(arr1, arr2) {\n        arr1 = unique(arr1);\n        arr2 = unique(arr2);\n\n        var a1 = filter(arr1, function(item){\n                return !contains(arr2, item);\n            }),\n            a2 = filter(arr2, function(item){\n                return !contains(arr1, item);\n            });\n\n        return a1.concat(a2);\n    }\n\n    module.exports = xor;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/array/zip.js":"var max = require('./max');\nvar map = require('./map');\n\n    function getLength(arr) {\n        return arr == null ? 0 : arr.length;\n    }\n\n    /**\n     * Merges together the values of each of the arrays with the values at the\n     * corresponding position.\n     */\n    function zip(arr){\n        var len = arr ? max(map(arguments, getLength)) : 0,\n            results = [],\n            i = -1;\n        while (++i < len) {\n            // jshint loopfunc: true\n            results.push(map(arguments, function(item) {\n                return item == null ? undefined : item[i];\n            }));\n        }\n\n        return results;\n    }\n\n    module.exports = zip;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'contains' : require('./collection/contains'),\n    'every' : require('./collection/every'),\n    'filter' : require('./collection/filter'),\n    'find' : require('./collection/find'),\n    'forEach' : require('./collection/forEach'),\n    'make_' : require('./collection/make_'),\n    'map' : require('./collection/map'),\n    'max' : require('./collection/max'),\n    'min' : require('./collection/min'),\n    'pluck' : require('./collection/pluck'),\n    'reduce' : require('./collection/reduce'),\n    'reject' : require('./collection/reject'),\n    'size' : require('./collection/size'),\n    'some' : require('./collection/some')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/contains.js":"var make = require('./make_');\nvar arrContains = require('../array/contains');\nvar objContains = require('../object/contains');\n\n    /**\n     */\n    module.exports = make(arrContains, objContains);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/make_.js":"var slice = require('../array/slice');\n\n    /**\n     * internal method used to create other collection modules.\n     */\n    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {\n        return function(){\n            var args = slice(arguments);\n            if (args[0] == null) {\n                return defaultReturn;\n            }\n            // array-like is treated as array\n            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);\n        };\n    }\n\n    module.exports = makeCollectionMethod;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/contains.js":"var some = require('./some');\n\n    /**\n     * Check if object contains value\n     */\n    function contains(obj, needle) {\n        return some(obj, function(val) {\n            return (val === needle);\n        });\n    }\n    module.exports = contains;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/some.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object some\n     */\n    function some(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = false;\n        forOwn(obj, function(val, key) {\n            if (callback(val, key, obj)) {\n                result = true;\n                return false; // break\n            }\n        });\n        return result;\n    }\n\n    module.exports = some;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/every.js":"var make = require('./make_');\nvar arrEvery = require('../array/every');\nvar objEvery = require('../object/every');\n\n    /**\n     */\n    module.exports = make(arrEvery, objEvery);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/every.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object every\n     */\n    function every(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = true;\n        forOwn(obj, function(val, key) {\n            // we consider any falsy values as \"false\" on purpose so shorthand\n            // syntax can be used to check property existence\n            if (!callback(val, key, obj)) {\n                result = false;\n                return false; // break\n            }\n        });\n        return result;\n    }\n\n    module.exports = every;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/filter.js":"var forEach = require('./forEach');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * filter collection values, returns array.\n     */\n    function filter(list, iterator, thisObj) {\n        iterator = makeIterator(iterator, thisObj);\n        var results = [];\n        if (!list) {\n            return results;\n        }\n        forEach(list, function(value, index, list) {\n            if (iterator(value, index, list)) {\n                results[results.length] = value;\n            }\n        });\n        return results;\n    }\n\n    module.exports = filter;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/forEach.js":"var make = require('./make_');\nvar arrForEach = require('../array/forEach');\nvar objForEach = require('../object/forOwn');\n\n    /**\n     */\n    module.exports = make(arrForEach, objForEach);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/find.js":"var make = require('./make_');\nvar arrFind = require('../array/find');\nvar objFind = require('../object/find');\n\n    /**\n     * Find value that returns true on iterator check.\n     */\n    module.exports = make(arrFind, objFind);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/find.js":"var some = require('./some');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Returns first item that matches criteria\n     */\n    function find(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result;\n        some(obj, function(value, key, obj) {\n            if (callback(value, key, obj)) {\n                result = value;\n                return true; //break\n            }\n        });\n        return result;\n    }\n\n    module.exports = find;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/map.js":"var isObject = require('../lang/isObject');\nvar values = require('../object/values');\nvar arrMap = require('../array/map');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Map collection values, returns Array.\n     */\n    function map(list, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        // list.length to check array-like object, if not array-like\n        // we simply map all the object values\n        if( isObject(list) && list.length == null ){\n            list = values(list);\n        }\n        return arrMap(list, function (val, key, list) {\n            return callback(val, key, list);\n        });\n    }\n\n    module.exports = map;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isObject.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isObject(val) {\n        return isKind(val, 'Object');\n    }\n    module.exports = isObject;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/values.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object values\n     */\n    function values(obj) {\n        var vals = [];\n        forOwn(obj, function(val, key){\n            vals.push(val);\n        });\n        return vals;\n    }\n\n    module.exports = values;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/max.js":"var make = require('./make_');\nvar arrMax = require('../array/max');\nvar objMax = require('../object/max');\n\n    /**\n     * Get maximum value inside collection\n     */\n    module.exports = make(arrMax, objMax);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/max.js":"var arrMax = require('../array/max');\nvar values = require('./values');\n\n    /**\n     * Returns maximum value inside object.\n     */\n    function max(obj, compareFn) {\n        return arrMax(values(obj), compareFn);\n    }\n\n    module.exports = max;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/min.js":"var make = require('./make_');\nvar arrMin = require('../array/min');\nvar objMin = require('../object/min');\n\n    /**\n     * Get minimum value inside collection.\n     */\n    module.exports = make(arrMin, objMin);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/min.js":"var arrMin = require('../array/min');\nvar values = require('./values');\n\n    /**\n     * Returns minimum value inside object.\n     */\n    function min(obj, iterator) {\n        return arrMin(values(obj), iterator);\n    }\n\n    module.exports = min;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/pluck.js":"var map = require('./map');\n\n    /**\n     * Extract a list of property values.\n     */\n    function pluck(list, key) {\n        return map(list, function(value) {\n            return value[key];\n        });\n    }\n\n    module.exports = pluck;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/reduce.js":"var make = require('./make_');\nvar arrReduce = require('../array/reduce');\nvar objReduce = require('../object/reduce');\n\n    /**\n     */\n    module.exports = make(arrReduce, objReduce);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/reduce.js":"var forOwn = require('./forOwn');\nvar size = require('./size');\n\n    /**\n     * Object reduce\n     */\n    function reduce(obj, callback, memo, thisObj) {\n        var initial = arguments.length > 2;\n\n        if (!size(obj) && !initial) {\n            throw new Error('reduce of empty object with no initial value');\n        }\n\n        forOwn(obj, function(value, key, list) {\n            if (!initial) {\n                memo = value;\n                initial = true;\n            }\n            else {\n                memo = callback.call(thisObj, memo, value, key, list);\n            }\n        });\n\n        return memo;\n    }\n\n    module.exports = reduce;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/size.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object size\n     */\n    function size(obj) {\n        var count = 0;\n        forOwn(obj, function(){\n            count++;\n        });\n        return count;\n    }\n\n    module.exports = size;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/reject.js":"var filter = require('./filter');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Inverse or collection/filter\n     */\n    function reject(list, iterator, thisObj) {\n        iterator = makeIterator(iterator, thisObj);\n        return filter(list, function(value, index, list) {\n            return !iterator(value, index, list);\n        }, thisObj);\n    }\n\n    module.exports = reject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/size.js":"var isArray = require('../lang/isArray');\nvar objSize = require('../object/size');\n\n    /**\n     * Get collection size\n     */\n    function size(list) {\n        if (!list) {\n            return 0;\n        }\n        if (isArray(list)) {\n            return list.length;\n        }\n        return objSize(list);\n    }\n\n    module.exports = size;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/collection/some.js":"var make = require('./make_');\nvar arrSome = require('../array/some');\nvar objSome = require('../object/some');\n\n    /**\n     */\n    module.exports = make(arrSome, objSome);\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'dayOfTheYear' : require('./date/dayOfTheYear'),\n    'diff' : require('./date/diff'),\n    'i18n_' : require('./date/i18n_'),\n    'isLeapYear' : require('./date/isLeapYear'),\n    'isSame' : require('./date/isSame'),\n    'parseIso' : require('./date/parseIso'),\n    'quarter' : require('./date/quarter'),\n    'startOf' : require('./date/startOf'),\n    'strftime' : require('./date/strftime'),\n    'timezoneAbbr' : require('./date/timezoneAbbr'),\n    'timezoneOffset' : require('./date/timezoneOffset'),\n    'totalDaysInMonth' : require('./date/totalDaysInMonth'),\n    'totalDaysInYear' : require('./date/totalDaysInYear'),\n    'weekOfTheYear' : require('./date/weekOfTheYear')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/dayOfTheYear.js":"var isDate = require('../lang/isDate');\n\n    /**\n     * return the day of the year (1..366)\n     */\n    function dayOfTheYear(date){\n        return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) -\n                Date.UTC(date.getFullYear(), 0, 1)) / 86400000 + 1;\n    }\n\n    module.exports = dayOfTheYear;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isDate.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isDate(val) {\n        return isKind(val, 'Date');\n    }\n    module.exports = isDate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/diff.js":"var totalDaysInMonth = require('./totalDaysInMonth');\nvar totalDaysInYear = require('./totalDaysInYear');\nvar convert = require('../time/convert');\n\n    /**\n     * calculate the difference between dates (range)\n     */\n    function diff(start, end, unitName){\n        // sort the dates to make it easier to process (specially year/month)\n        if (start > end) {\n            var swap = start;\n            start = end;\n            end = swap;\n        }\n\n        var output;\n\n        if (unitName === 'month') {\n            output = getMonthsDiff(start, end);\n        } else if (unitName === 'year'){\n            output = getYearsDiff(start, end);\n        } else if (unitName != null) {\n            if (unitName === 'day') {\n                // ignore timezone difference because of daylight savings time\n                start = toUtc(start);\n                end = toUtc(end);\n            }\n            output = convert(end - start, 'ms', unitName);\n        } else {\n            output = end - start;\n        }\n\n        return output;\n    }\n\n\n    function toUtc(d){\n        // we ignore timezone differences on purpose because of daylight\n        // savings time, otherwise it would return fractional days/weeks even\n        // if a full day elapsed. eg:\n        // Wed Feb 12 2014 00:00:00 GMT-0200 (BRST)\n        // Sun Feb 16 2014 00:00:00 GMT-0300 (BRT)\n        // diff should be 4 days and not 4.041666666666667\n        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(),\n                        d.getHours(), d.getMinutes(), d.getSeconds(),\n                        d.getMilliseconds());\n    }\n\n\n    function getMonthsDiff(start, end){\n        return getElapsedMonths(start, end) +\n               getElapsedYears(start, end) * 12 +\n               getFractionalMonth(start, end);\n    }\n\n\n    function getYearsDiff(start, end){\n        var elapsedYears = getElapsedYears(start, end);\n        return elapsedYears + getFractionalYear(start, end, elapsedYears);\n    }\n\n\n    function getElapsedMonths(start, end){\n        var monthDiff = end.getMonth() - start.getMonth();\n        if (monthDiff < 0) {\n            monthDiff += 12;\n        }\n        // less than a full month\n        if (start.getDate() > end.getDate()) {\n            monthDiff -= 1;\n        }\n        return monthDiff;\n    }\n\n\n    function getElapsedYears(start, end){\n        var yearDiff = end.getFullYear() - start.getFullYear();\n        // less than a full year\n        if (start.getMonth() > end.getMonth()) {\n            yearDiff -= 1;\n        }\n        return yearDiff;\n    }\n\n\n    function getFractionalMonth(start, end){\n        var fractionalDiff = 0;\n        var startDay = start.getDate();\n        var endDay = end.getDate();\n\n        if (startDay !== endDay) {\n            var startTotalDays = totalDaysInMonth(start);\n            var endTotalDays = totalDaysInMonth(end);\n            var totalDays;\n            var daysElapsed;\n\n            if (startDay > endDay) {\n                // eg: Jan 29 - Feb 27 (29 days elapsed but not a full month)\n                var baseDay = startTotalDays - startDay;\n                daysElapsed = endDay + baseDay;\n                // total days should be relative to 1st day of next month if\n                // startDay > endTotalDays\n                totalDays = (startDay > endTotalDays)?\n                    endTotalDays + baseDay + 1 : startDay + baseDay;\n            } else {\n                // fractional is only based on endMonth eg: Jan 12 - Feb 18\n                // (6 fractional days, 28 days until next full month)\n                daysElapsed = endDay - startDay;\n                totalDays = endTotalDays;\n            }\n\n            fractionalDiff = daysElapsed / totalDays;\n        }\n\n        return fractionalDiff;\n    }\n\n\n    function getFractionalYear(start, end, elapsedYears){\n        var base = elapsedYears?\n            new Date(end.getFullYear(), start.getMonth(), start.getDate()) :\n            start;\n        var elapsedDays = diff(base, end, 'day');\n        return elapsedDays / totalDaysInYear(end);\n    }\n\n\n    module.exports = diff;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/totalDaysInMonth.js":"var isDate = require('../lang/isDate');\nvar isLeapYear = require('./isLeapYear');\n\n    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    /**\n     * returns the total amount of days in the month (considering leap years)\n     */\n    function totalDaysInMonth(fullYear, monthIndex){\n        if (isDate(fullYear)) {\n            monthIndex = fullYear.getMonth();\n        }\n\n        if (monthIndex === 1 && isLeapYear(fullYear)) {\n            return 29;\n        } else {\n            return DAYS_IN_MONTH[monthIndex];\n        }\n    }\n\n    module.exports = totalDaysInMonth;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/isLeapYear.js":"var isDate = require('../lang/isDate');\n\n    /**\n     * checks if it's a leap year\n     */\n    function isLeapYear(fullYear){\n        if (isDate(fullYear)) {\n            fullYear = fullYear.getFullYear();\n        }\n        return fullYear % 400 === 0 || (fullYear % 100 !== 0 && fullYear % 4 === 0);\n    }\n\n    module.exports = isLeapYear;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/totalDaysInYear.js":"var isLeapYear = require('./isLeapYear');\n\n    /**\n     * return the amount of days in the year following the gregorian calendar\n     * and leap years\n     */\n    function totalDaysInYear(fullYear){\n        return isLeapYear(fullYear)? 366 : 365;\n    }\n\n    module.exports = totalDaysInYear;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/time/convert.js":"\n\n    /**\n     * convert time into another unit\n     */\n    function convert(val, sourceUnitName, destinationUnitName){\n        destinationUnitName = destinationUnitName || 'ms';\n        return (val * getUnit(sourceUnitName)) / getUnit(destinationUnitName);\n    }\n\n\n    //TODO: maybe extract to a separate module\n    function getUnit(unitName){\n        switch(unitName){\n            case 'ms':\n            case 'millisecond':\n                return 1;\n            case 's':\n            case 'second':\n                 return 1000;\n            case 'm':\n            case 'minute':\n                 return 60000;\n            case 'h':\n            case 'hour':\n                 return 3600000;\n            case 'd':\n            case 'day':\n                 return 86400000;\n            case 'w':\n            case 'week':\n                 return 604800000;\n            default:\n                throw new Error('\"'+ unitName + '\" is not a valid unit');\n        }\n    }\n\n\n    module.exports = convert;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/i18n_.js":"var mixIn = require('../object/mixIn');\nvar enUS = require('./i18n/en-US');\n\n    // we also use mixIn to make sure we don't affect the original locale\n    var activeLocale = mixIn({}, enUS, {\n        // we expose a \"set\" method to allow overriding the global locale\n        set : function(localeData){\n            mixIn(activeLocale, localeData);\n        }\n    });\n\n    module.exports = activeLocale;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/mixIn.js":"var forOwn = require('./forOwn');\n\n    /**\n    * Combine properties from all the objects into first one.\n    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.\n    * @param {object} target    Target Object\n    * @param {...object} objects    Objects to be combined (0...n objects).\n    * @return {object} Target Object.\n    */\n    function mixIn(target, objects){\n        var i = 0,\n            n = arguments.length,\n            obj;\n        while(++i < n){\n            obj = arguments[i];\n            if (obj != null) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n        return target;\n    }\n\n    function copyProp(val, key){\n        this[key] = val;\n    }\n\n    module.exports = mixIn;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/i18n/en-US.js":"\n    // en-US (English, United States)\n    module.exports = {\n        \"am\" : \"AM\",\n        \"pm\" : \"PM\",\n\n        \"x\": \"%m/%d/%y\",\n        \"X\": \"%H:%M:%S\",\n        \"c\": \"%a %d %b %Y %I:%M:%S %p %Z\",\n\n        \"months\" : [\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\"\n        ],\n\n        \"months_abbr\" : [\n            \"Jan\",\n            \"Feb\",\n            \"Mar\",\n            \"Apr\",\n            \"May\",\n            \"Jun\",\n            \"Jul\",\n            \"Aug\",\n            \"Sep\",\n            \"Oct\",\n            \"Nov\",\n            \"Dec\"\n        ],\n\n        \"days\" : [\n            \"Sunday\",\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\"\n        ],\n\n        \"days_abbr\" : [\n            \"Sun\",\n            \"Mon\",\n            \"Tue\",\n            \"Wed\",\n            \"Thu\",\n            \"Fri\",\n            \"Sat\"\n        ]\n    };\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/isSame.js":"var startOf = require('./startOf');\n\n    /**\n     * Check if date is \"same\" with optional period\n     */\n    function isSame(date1, date2, period){\n        if (period) {\n            date1 = startOf(date1, period);\n            date2 = startOf(date2, period);\n        }\n        return Number(date1) === Number(date2);\n    }\n\n    module.exports = isSame;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/startOf.js":"var clone = require('../lang/clone');\n\n    /**\n     * get a new Date object representing start of period\n     */\n    function startOf(date, period){\n        date = clone(date);\n\n        // intentionally removed \"break\" from switch since start of\n        // month/year/etc should also reset the following periods\n        switch (period) {\n            case 'year':\n                date.setMonth(0);\n            /* falls through */\n            case 'month':\n                date.setDate(1);\n            /* falls through */\n            case 'week':\n            case 'day':\n                date.setHours(0);\n            /* falls through */\n            case 'hour':\n                date.setMinutes(0);\n            /* falls through */\n            case 'minute':\n                date.setSeconds(0);\n            /* falls through */\n            case 'second':\n                date.setMilliseconds(0);\n                break;\n            default:\n                throw new Error('\"'+ period +'\" is not a valid period');\n        }\n\n        // week is the only case that should reset the weekDay and maybe even\n        // overflow to previous month\n        if (period === 'week') {\n            var weekDay = date.getDay();\n            var baseDate = date.getDate();\n            if (weekDay) {\n                if (weekDay >= baseDate) {\n                    //start of the week is on previous month\n                    date.setDate(0);\n                }\n                date.setDate(date.getDate() - date.getDay());\n            }\n        }\n\n        return date;\n    }\n\n    module.exports = startOf;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/clone.js":"var kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\nvar mixIn = require('../object/mixIn');\n\n    /**\n     * Clone native types.\n     */\n    function clone(val){\n        switch (kindOf(val)) {\n            case 'Object':\n                return cloneObject(val);\n            case 'Array':\n                return cloneArray(val);\n            case 'RegExp':\n                return cloneRegExp(val);\n            case 'Date':\n                return cloneDate(val);\n            default:\n                return val;\n        }\n    }\n\n    function cloneObject(source) {\n        if (isPlainObject(source)) {\n            return mixIn({}, source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneRegExp(r) {\n        var flags = '';\n        flags += r.multiline ? 'm' : '';\n        flags += r.global ? 'g' : '';\n        flags += r.ignoreCase ? 'i' : '';\n        return new RegExp(r.source, flags);\n    }\n\n    function cloneDate(date) {\n        return new Date(+date);\n    }\n\n    function cloneArray(arr) {\n        return arr.slice();\n    }\n\n    module.exports = clone;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isPlainObject.js":"\n\n    /**\n     * Checks if the value is created by the `Object` constructor.\n     */\n    function isPlainObject(value) {\n        return (!!value && typeof value === 'object' &&\n            value.constructor === Object);\n    }\n\n    module.exports = isPlainObject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/parseIso.js":"var some = require('../array/some');\n\n    var datePatterns = [\n        /^([0-9]{4})$/,                        // YYYY\n        /^([0-9]{4})-([0-9]{2})$/,             // YYYY-MM (YYYYMM not allowed)\n        /^([0-9]{4})-?([0-9]{2})-?([0-9]{2})$/ // YYYY-MM-DD or YYYYMMDD\n    ];\n    var ORD_DATE = /^([0-9]{4})-?([0-9]{3})$/; // YYYY-DDD\n\n    var timePatterns = [\n        /^([0-9]{2}(?:\\.[0-9]*)?)$/,                      // HH.hh\n        /^([0-9]{2}):?([0-9]{2}(?:\\.[0-9]*)?)$/,          // HH:MM.mm\n        /^([0-9]{2}):?([0-9]{2}):?([0-9]{2}(\\.[0-9]*)?)$/ // HH:MM:SS.ss\n    ];\n\n    var DATE_TIME = /^(.+)T(.+)$/;\n    var TIME_ZONE = /^(.+)([+\\-])([0-9]{2}):?([0-9]{2})$/;\n\n    function matchAll(str, patterns) {\n        var match;\n        var found = some(patterns, function(pattern) {\n            return !!(match = pattern.exec(str));\n        });\n\n        return found ? match : null;\n    }\n\n    function getDate(year, month, day) {\n        var date = new Date(Date.UTC(year, month, day));\n\n        // Explicitly set year to avoid Date.UTC making dates < 100 relative to\n        // 1900\n        date.setUTCFullYear(year);\n\n        var valid =\n            date.getUTCFullYear() === year &&\n            date.getUTCMonth() === month &&\n            date.getUTCDate() === day;\n        return valid ? +date : NaN;\n    }\n\n    function parseOrdinalDate(str) {\n        var match = ORD_DATE.exec(str);\n        if (match ) {\n            var year = +match[1],\n                day = +match[2],\n                date = new Date(Date.UTC(year, 0, day));\n\n            if (date.getUTCFullYear() === year) {\n                return +date;\n            }\n        }\n\n        return NaN;\n    }\n\n    function parseDate(str) {\n        var match, year, month, day;\n\n        match = matchAll(str, datePatterns);\n        if (match === null) {\n            // Ordinal dates are verified differently.\n            return parseOrdinalDate(str);\n        }\n\n        year = (match[1] === void 0) ? 0 : +match[1];\n        month = (match[2] === void 0) ? 0 : +match[2] - 1;\n        day = (match[3] === void 0) ? 1 : +match[3];\n\n        return getDate(year, month, day);\n    }\n\n    function getTime(hr, min, sec) {\n        var valid =\n            (hr < 24 && hr >= 0 &&\n             min < 60 && min >= 0 &&\n             sec < 60 && min >= 0) ||\n            (hr === 24 && min === 0 && sec === 0);\n        if (!valid) {\n            return NaN;\n        }\n\n        return ((hr * 60 + min) * 60 + sec) * 1000;\n    }\n\n    function parseOffset(str) {\n        var match;\n        if (str.charAt(str.length - 1) === 'Z') {\n            str = str.substring(0, str.length - 1);\n        } else {\n            match = TIME_ZONE.exec(str);\n            if (match) {\n                var hours = +match[3],\n                    minutes = (match[4] === void 0) ? 0 : +match[4],\n                    offset = getTime(hours, minutes, 0);\n\n                if (match[2] === '-') {\n                    offset *= -1;\n                }\n\n                return { offset: offset, time: match[1] };\n            }\n        }\n\n        // No time zone specified, assume UTC\n        return { offset: 0, time: str };\n    }\n\n    function parseTime(str) {\n        var match;\n        var offset = parseOffset(str);\n\n        str = offset.time;\n        offset = offset.offset;\n        if (isNaN(offset)) {\n            return NaN;\n        }\n\n        match = matchAll(str, timePatterns);\n        if (match === null) {\n            return NaN;\n        }\n\n        var hours = (match[1] === void 0) ? 0 : +match[1],\n            minutes = (match[2] === void 0) ? 0 : +match[2],\n            seconds = (match[3] === void 0) ? 0 : +match[3];\n\n        return getTime(hours, minutes, seconds) - offset;\n    }\n\n    /**\n     * Parse an ISO8601 formatted date string, and return a Date object.\n     */\n    function parseISO8601(str){\n        var match = DATE_TIME.exec(str);\n        if (!match) {\n            // No time specified\n            return parseDate(str);\n        }\n\n        return parseDate(match[1]) + parseTime(match[2]);\n    }\n\n    module.exports = parseISO8601;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/quarter.js":"\n\n    /**\n     * gets date quarter\n     */\n    function quarter(date){\n        var month = date.getMonth();\n        if (month < 3) return 1;\n        if (month < 6) return 2;\n        if (month < 9) return 3;\n        return 4;\n    }\n\n    module.exports = quarter;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/strftime.js":"var pad = require('../number/pad');\nvar lpad = require('../string/lpad');\nvar i18n = require('./i18n_');\nvar dayOfTheYear = require('./dayOfTheYear');\nvar timezoneOffset = require('./timezoneOffset');\nvar timezoneAbbr = require('./timezoneAbbr');\nvar weekOfTheYear = require('./weekOfTheYear');\n\n    var _combinations = {\n        'D': '%m/%d/%y',\n        'F': '%Y-%m-%d',\n        'r': '%I:%M:%S %p',\n        'R': '%H:%M',\n        'T': '%H:%M:%S',\n        'x': 'locale',\n        'X': 'locale',\n        'c': 'locale'\n    };\n\n\n    /**\n     * format date based on strftime format\n     */\n    function strftime(date, format, localeData){\n        localeData = localeData  || i18n;\n        var reToken = /%([a-z%])/gi;\n\n        function makeIterator(fn) {\n            return function(match, token){\n                return fn(date, token, localeData);\n            };\n        }\n\n        return format\n            .replace(reToken, makeIterator(expandCombinations))\n            .replace(reToken, makeIterator(convertToken));\n    }\n\n\n    function expandCombinations(date, token, l10n){\n        if (token in _combinations) {\n            var expanded = _combinations[token];\n            return expanded === 'locale'? l10n[token] : expanded;\n        } else {\n            return '%'+ token;\n        }\n    }\n\n\n    function convertToken(date, token, l10n){\n        switch (token){\n            case 'a':\n                return l10n.days_abbr[date.getDay()];\n            case 'A':\n                return l10n.days[date.getDay()];\n            case 'h':\n            case 'b':\n                return l10n.months_abbr[date.getMonth()];\n            case 'B':\n                return l10n.months[date.getMonth()];\n            case 'C':\n                return pad(Math.floor(date.getFullYear() / 100), 2);\n            case 'd':\n                return pad(date.getDate(), 2);\n            case 'e':\n                return pad(date.getDate(), 2, ' ');\n            case 'H':\n                return pad(date.getHours(), 2);\n            case 'I':\n                return pad(date.getHours() % 12, 2);\n            case 'j':\n                return pad(dayOfTheYear(date), 3);\n            case 'l':\n                return lpad(date.getHours() % 12, 2);\n            case 'L':\n                return pad(date.getMilliseconds(), 3);\n            case 'm':\n                return pad(date.getMonth() + 1, 2);\n            case 'M':\n                return pad(date.getMinutes(), 2);\n            case 'n':\n                return '\\n';\n            case 'p':\n                return date.getHours() >= 12? l10n.pm : l10n.am;\n            case 'P':\n                return convertToken(date, 'p', l10n).toLowerCase();\n            case 's':\n                return date.getTime() / 1000;\n            case 'S':\n                return pad(date.getSeconds(), 2);\n            case 't':\n                return '\\t';\n            case 'u':\n                var day = date.getDay();\n                return day === 0? 7 : day;\n            case 'U':\n                return pad(weekOfTheYear(date), 2);\n            case 'w':\n                return date.getDay();\n            case 'W':\n                return pad(weekOfTheYear(date, 1), 2);\n            case 'y':\n                return pad(date.getFullYear() % 100, 2);\n            case 'Y':\n                return pad(date.getFullYear(), 4);\n            case 'z':\n                return timezoneOffset(date);\n            case 'Z':\n                return timezoneAbbr(date);\n            case '%':\n                return '%';\n            default:\n                // keep unrecognized tokens\n                return '%'+ token;\n        }\n    }\n\n\n    module.exports = strftime;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/pad.js":"var lpad = require('../string/lpad');\nvar toNumber = require('../lang/toNumber');\n\n    /**\n     * Add padding zeros if n.length < minLength.\n     */\n    function pad(n, minLength, char){\n        n = toNumber(n);\n        return lpad(''+ n, minLength, char || '0');\n    }\n\n    module.exports = pad;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/lpad.js":"var toString = require('../lang/toString');\nvar repeat = require('./repeat');\n\n    /**\n     * Pad string with `char` if its' length is smaller than `minLen`\n     */\n    function lpad(str, minLen, ch) {\n        str = toString(str);\n        ch = ch || ' ';\n\n        return (str.length < minLen) ?\n            repeat(ch, minLen - str.length) + str : str;\n    }\n\n    module.exports = lpad;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/toString.js":"\n\n    /**\n     * Typecast a value to a String, using an empty string value for null or\n     * undefined.\n     */\n    function toString(val){\n        return val == null ? '' : val.toString();\n    }\n\n    module.exports = toString;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/repeat.js":"var toString = require('../lang/toString');\nvar toInt = require('../number/toInt');\n\n    /**\n     * Repeat string n times\n     */\n     function repeat(str, n){\n         var result = '';\n         str = toString(str);\n         n = toInt(n);\n        if (n < 1) {\n            return '';\n        }\n        while (n > 0) {\n            if (n % 2) {\n                result += str;\n            }\n            n = Math.floor(n / 2);\n            str += str;\n        }\n        return result;\n     }\n\n     module.exports = repeat;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/toInt.js":"\n\n    /**\n     * \"Convert\" value into an 32-bit integer.\n     * Works like `Math.floor` if val > 0 and `Math.ceil` if val < 0.\n     * IMPORTANT: val will wrap at 2^31 and -2^31.\n     * Perf tests: http://jsperf.com/vs-vs-parseint-bitwise-operators/7\n     */\n    function toInt(val){\n        // we do not use lang/toNumber because of perf and also because it\n        // doesn't break the functionality\n        return ~~val;\n    }\n\n    module.exports = toInt;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/toNumber.js":"var isArray = require('./isArray');\n\n    /**\n     * covert value into number if numeric\n     */\n    function toNumber(val){\n        // numberic values should come first because of -0\n        if (typeof val === 'number') return val;\n        // we want all falsy values (besides -0) to return zero to avoid\n        // headaches\n        if (!val) return 0;\n        if (typeof val === 'string') return parseFloat(val);\n        // arrays are edge cases. `Number([4]) === 4`\n        if (isArray(val)) return NaN;\n        return Number(val);\n    }\n\n    module.exports = toNumber;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/timezoneOffset.js":"var pad = require('../number/pad');\n\n    /**\n     * time zone as hour and minute offset from UTC (e.g. +0900)\n     */\n    function timezoneOffset(date){\n        var offset = date.getTimezoneOffset();\n        var abs = Math.abs(offset);\n        var h = pad(Math.floor(abs / 60), 2);\n        var m = pad(abs % 60, 2);\n        return (offset > 0? '-' : '+') + h + m;\n    }\n\n    module.exports = timezoneOffset;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/timezoneAbbr.js":"var timezoneOffset = require('./timezoneOffset');\n\n    /**\n     * Abbreviated time zone name or similar information.\n     */\n    function timezoneAbbr(date){\n        // Date.toString gives different results depending on the\n        // browser/system so we fallback to timezone offset\n        // chrome: 'Mon Apr 08 2013 09:02:04 GMT-0300 (BRT)'\n        // IE: 'Mon Apr 8 09:02:04 UTC-0300 2013'\n        var tz = /\\(([A-Z]{3,4})\\)/.exec(date.toString());\n        return tz? tz[1] : timezoneOffset(date);\n    }\n\n    module.exports = timezoneAbbr;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/date/weekOfTheYear.js":"var dayOfTheYear = require('./dayOfTheYear');\n\n    /**\n     * Return the week of the year based on given firstDayOfWeek\n     */\n    function weekOfTheYear(date, firstDayOfWeek){\n        firstDayOfWeek = firstDayOfWeek == null? 0 : firstDayOfWeek;\n        var doy = dayOfTheYear(date);\n        var dow = (7 + date.getDay() - firstDayOfWeek) % 7;\n        var relativeWeekDay = 6 - firstDayOfWeek - dow;\n        return Math.floor((doy + relativeWeekDay) / 7);\n    }\n\n    module.exports = weekOfTheYear;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'awaitDelay' : require('./function/awaitDelay'),\n    'bind' : require('./function/bind'),\n    'compose' : require('./function/compose'),\n    'constant' : require('./function/constant'),\n    'debounce' : require('./function/debounce'),\n    'func' : require('./function/func'),\n    'identity' : require('./function/identity'),\n    'makeIterator_' : require('./function/makeIterator_'),\n    'partial' : require('./function/partial'),\n    'prop' : require('./function/prop'),\n    'series' : require('./function/series'),\n    'throttle' : require('./function/throttle'),\n    'timeout' : require('./function/timeout'),\n    'times' : require('./function/times'),\n    'wrap' : require('./function/wrap')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/awaitDelay.js":"var now = require('../time/now');\nvar timeout = require('./timeout');\nvar append = require('../array/append');\n\n    /**\n     * Ensure a minimum delay for callbacks\n     */\n    function awaitDelay( callback, delay ){\n        var baseTime = now() + delay;\n        return function() {\n            // ensure all browsers will execute it asynchronously (avoid hard\n            // to catch errors) not using \"0\" because of old browsers and also\n            // since new browsers increase the value to be at least \"4\"\n            // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout\n            var ms = Math.max(baseTime - now(), 4);\n            return timeout.apply(this, append([callback, ms, this], arguments));\n        };\n    }\n\n    module.exports = awaitDelay;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/time/now.js":"\n\n    /**\n     * Get current time in miliseconds\n     */\n    function now(){\n        // yes, we defer the work to another function to allow mocking it\n        // during the tests\n        return now.get();\n    }\n\n    now.get = (typeof Date.now === 'function')? Date.now : function(){\n        return +(new Date());\n    };\n\n    module.exports = now;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/timeout.js":"var slice = require('../array/slice');\n\n    /**\n     * Delays the call of a function within a given context.\n     */\n    function timeout(fn, millis, context){\n\n        var args = slice(arguments, 3);\n\n        return setTimeout(function() {\n            fn.apply(context, args);\n        }, millis);\n    }\n\n    module.exports = timeout;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/bind.js":"var slice = require('../array/slice');\n\n    /**\n     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.\n     * @param {Function} fn  Function.\n     * @param {object} context   Execution context.\n     * @param {rest} args    Arguments (0...n arguments).\n     * @return {Function} Wrapped Function.\n     */\n    function bind(fn, context, args){\n        var argsArr = slice(arguments, 2); //curried args\n        return function(){\n            return fn.apply(context, argsArr.concat(slice(arguments)));\n        };\n    }\n\n    module.exports = bind;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/compose.js":"\n\n    /**\n     * Returns a function that composes multiple functions, passing results to\n     * each other.\n     */\n    function compose() {\n        var fns = arguments;\n        return function(arg){\n            // only cares about the first argument since the chain can only\n            // deal with a single return value anyway. It should start from\n            // the last fn.\n            var n = fns.length;\n            while (n--) {\n                arg = fns[n].call(this, arg);\n            }\n            return arg;\n         };\n     }\n\n     module.exports = compose;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/constant.js":"\n\n    /**\n     * Returns a new function that will return the value\n     */\n    function constant(value){\n        return function() {\n            return value;\n        };\n    }\n\n    module.exports = constant;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/debounce.js":"\n\n    /**\n     * Debounce callback execution\n     */\n    function debounce(fn, threshold, isAsap){\n        var timeout, result;\n        function debounced(){\n            var args = arguments, context = this;\n            function delayed(){\n                if (! isAsap) {\n                    result = fn.apply(context, args);\n                }\n                timeout = null;\n            }\n            if (timeout) {\n                clearTimeout(timeout);\n            } else if (isAsap) {\n                result = fn.apply(context, args);\n            }\n            timeout = setTimeout(delayed, threshold);\n            return result;\n        }\n        debounced.cancel = function(){\n            clearTimeout(timeout);\n        };\n        return debounced;\n    }\n\n    module.exports = debounce;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/func.js":"\n\n    /**\n     * Returns a function that call a method on the passed object\n     */\n    function func(name){\n        return function(obj){\n            return obj[name]();\n        };\n    }\n\n    module.exports = func;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/partial.js":"var slice = require('../array/slice');\n\n    /**\n     * Creates a partially applied function.\n     */\n    function partial(f) {\n        var as = slice(arguments, 1);\n        return function() {\n            var args = as.concat(slice(arguments));\n            for (var i = args.length; i--;) {\n                if (args[i] === partial._) {\n                    args[i] = args.splice(-1)[0];\n                }\n            }\n            return f.apply(this, args);\n        };\n    }\n\n    partial._ = {};\n\n    module.exports = partial;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/series.js":"\n\n    /**\n     * Returns a function that will execute a list of functions in sequence\n     * passing the same arguments to each one. (useful for batch processing\n     * items during a forEach loop)\n     */\n    function series(){\n        var fns = arguments;\n        return function(){\n            var i = 0,\n                n = fns.length;\n            while (i < n) {\n                fns[i].apply(this, arguments);\n                i += 1;\n            }\n        };\n    }\n\n    module.exports = series;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/throttle.js":"var now = require('../time/now');\n\n    /**\n     */\n    function throttle(fn, delay){\n        var context, timeout, result, args,\n            diff, prevCall = 0;\n        function delayed(){\n            prevCall = now();\n            timeout = null;\n            result = fn.apply(context, args);\n        }\n        function throttled(){\n            context = this;\n            args = arguments;\n            diff = delay - (now() - prevCall);\n            if (diff <= 0) {\n                clearTimeout(timeout);\n                delayed();\n            } else if (! timeout) {\n                timeout = setTimeout(delayed, diff);\n            }\n            return result;\n        }\n        throttled.cancel = function(){\n            clearTimeout(timeout);\n        };\n        return throttled;\n    }\n\n    module.exports = throttle;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/times.js":"\n\n    /**\n     * Iterates over a callback a set amount of times\n     */\n    function times(n, callback, thisObj){\n        var i = -1;\n        while (++i < n) {\n            if ( callback.call(thisObj, i) === false ) {\n                break;\n            }\n        }\n    }\n\n    module.exports = times;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/function/wrap.js":"var partial = require('./partial');\n\n    /**\n     * Returns the first function passed as an argument to the second,\n     * allowing you to adjust arguments, run code before and after, and\n     * conditionally execute the original function.\n     */\n    function wrap(fn, wrapper){\n        return partial(wrapper, fn);\n    }\n\n    module.exports = wrap;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'GLOBAL' : require('./lang/GLOBAL'),\n    'clone' : require('./lang/clone'),\n    'createObject' : require('./lang/createObject'),\n    'ctorApply' : require('./lang/ctorApply'),\n    'deepClone' : require('./lang/deepClone'),\n    'deepEquals' : require('./lang/deepEquals'),\n    'defaults' : require('./lang/defaults'),\n    'inheritPrototype' : require('./lang/inheritPrototype'),\n    'is' : require('./lang/is'),\n    'isArguments' : require('./lang/isArguments'),\n    'isArray' : require('./lang/isArray'),\n    'isBoolean' : require('./lang/isBoolean'),\n    'isDate' : require('./lang/isDate'),\n    'isEmpty' : require('./lang/isEmpty'),\n    'isFinite' : require('./lang/isFinite'),\n    'isFunction' : require('./lang/isFunction'),\n    'isInteger' : require('./lang/isInteger'),\n    'isKind' : require('./lang/isKind'),\n    'isNaN' : require('./lang/isNaN'),\n    'isNull' : require('./lang/isNull'),\n    'isNumber' : require('./lang/isNumber'),\n    'isObject' : require('./lang/isObject'),\n    'isPlainObject' : require('./lang/isPlainObject'),\n    'isPrimitive' : require('./lang/isPrimitive'),\n    'isRegExp' : require('./lang/isRegExp'),\n    'isString' : require('./lang/isString'),\n    'isUndefined' : require('./lang/isUndefined'),\n    'isnt' : require('./lang/isnt'),\n    'kindOf' : require('./lang/kindOf'),\n    'toArray' : require('./lang/toArray'),\n    'toNumber' : require('./lang/toNumber'),\n    'toString' : require('./lang/toString')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/GLOBAL.js":"\n\n    // Reference to the global context (works on ES3 and ES5-strict mode)\n    //jshint -W061, -W064\n    module.exports = Function('return this')();\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/createObject.js":"var mixIn = require('../object/mixIn');\n\n    /**\n     * Create Object using prototypal inheritance and setting custom properties.\n     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.\n     * @param {object} parent    Parent Object.\n     * @param {object} [props] Object properties.\n     * @return {object} Created object.\n     */\n    function createObject(parent, props){\n        function F(){}\n        F.prototype = parent;\n        return mixIn(new F(), props);\n\n    }\n    module.exports = createObject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/ctorApply.js":"\n\n    function F(){}\n\n    /**\n     * Do fn.apply on a constructor.\n     */\n    function ctorApply(ctor, args) {\n        F.prototype = ctor.prototype;\n        var instance = new F();\n        ctor.apply(instance, args);\n        return instance;\n    }\n\n    module.exports = ctorApply;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/deepClone.js":"var clone = require('./clone');\nvar forOwn = require('../object/forOwn');\nvar kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\n\n    /**\n     * Recursively clone native types.\n     */\n    function deepClone(val, instanceClone) {\n        switch ( kindOf(val) ) {\n            case 'Object':\n                return cloneObject(val, instanceClone);\n            case 'Array':\n                return cloneArray(val, instanceClone);\n            default:\n                return clone(val);\n        }\n    }\n\n    function cloneObject(source, instanceClone) {\n        if (isPlainObject(source)) {\n            var out = {};\n            forOwn(source, function(val, key) {\n                this[key] = deepClone(val, instanceClone);\n            }, out);\n            return out;\n        } else if (instanceClone) {\n            return instanceClone(source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneArray(arr, instanceClone) {\n        var out = [],\n            i = -1,\n            n = arr.length,\n            val;\n        while (++i < n) {\n            out[i] = deepClone(arr[i], instanceClone);\n        }\n        return out;\n    }\n\n    module.exports = deepClone;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/deepEquals.js":"var is = require('./is');\nvar isObject = require('./isObject');\nvar isArray = require('./isArray');\nvar objEquals = require('../object/equals');\nvar arrEquals = require('../array/equals');\n\n    /**\n     * Recursively checks for same properties and values.\n     */\n    function deepEquals(a, b, callback){\n        callback = callback || is;\n\n        var bothObjects = isObject(a) && isObject(b);\n        var bothArrays = !bothObjects && isArray(a) && isArray(b);\n\n        if (!bothObjects && !bothArrays) {\n            return callback(a, b);\n        }\n\n        function compare(a, b){\n            return deepEquals(a, b, callback);\n        }\n\n        var method = bothObjects ? objEquals : arrEquals;\n        return method(a, b, compare);\n    }\n\n    module.exports = deepEquals;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/equals.js":"var hasOwn = require('./hasOwn');\nvar every = require('./every');\nvar isObject = require('../lang/isObject');\nvar is = require('../lang/is');\n\n    // Makes a function to compare the object values from the specified compare\n    // operation callback.\n    function makeCompare(callback) {\n        return function(value, key) {\n            return hasOwn(this, key) && callback(value, this[key]);\n        };\n    }\n\n    function checkProperties(value, key) {\n        return hasOwn(this, key);\n    }\n\n    /**\n     * Checks if two objects have the same keys and values.\n     */\n    function equals(a, b, callback) {\n        callback = callback || is;\n\n        if (!isObject(a) || !isObject(b)) {\n            return callback(a, b);\n        }\n\n        return (every(a, makeCompare(callback), b) &&\n                every(b, checkProperties, a));\n    }\n\n    module.exports = equals;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/defaults.js":"var toArray = require('./toArray');\nvar find = require('../array/find');\n\n    /**\n     * Return first non void argument\n     */\n    function defaults(var_args){\n        return find(toArray(arguments), nonVoid);\n    }\n\n    function nonVoid(val){\n        return val != null;\n    }\n\n    module.exports = defaults;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/toArray.js":"var kindOf = require('./kindOf');\nvar GLOBAL = require('./GLOBAL');\n\n    /**\n     * Convert array-like object into array\n     */\n    function toArray(val){\n        var ret = [],\n            kind = kindOf(val),\n            n;\n\n        if (val != null) {\n            if ( val.length == null || kind === 'String' || kind === 'Function' || kind === 'RegExp' || val === GLOBAL ) {\n                //string, regexp, function have .length but user probably just want\n                //to wrap value into an array..\n                ret[ret.length] = val;\n            } else {\n                //window returns true on isObject in IE7 and may have length\n                //property. `typeof NodeList` returns `function` on Safari so\n                //we can't use it (#58)\n                n = val.length;\n                while (n--) {\n                    ret[n] = val[n];\n                }\n            }\n        }\n        return ret;\n    }\n    module.exports = toArray;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/inheritPrototype.js":"var createObject = require('./createObject');\n\n    /**\n    * Inherit prototype from another Object.\n    * - inspired by Nicholas Zackas <http://nczonline.net> Solution\n    * @param {object} child Child object\n    * @param {object} parent    Parent Object\n    */\n    function inheritPrototype(child, parent){\n        var p = createObject(parent.prototype);\n        p.constructor = child;\n        child.prototype = p;\n        child.super_ = parent;\n        return p;\n    }\n\n    module.exports = inheritPrototype;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isArguments.js":"var isKind = require('./isKind');\n\n    /**\n     */\n    var isArgs = isKind(arguments, 'Arguments')?\n            function(val){\n                return isKind(val, 'Arguments');\n            } :\n            function(val){\n                // Arguments is an Object on IE7\n                return !!(val && Object.prototype.hasOwnProperty.call(val, 'callee'));\n            };\n\n    module.exports = isArgs;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isBoolean.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isBoolean(val) {\n        return isKind(val, 'Boolean');\n    }\n    module.exports = isBoolean;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isEmpty.js":"var forOwn = require('../object/forOwn');\nvar isArray = require('./isArray');\n\n    function isEmpty(val){\n        if (val == null) {\n            // typeof null == 'object' so we check it first\n            return true;\n        } else if ( typeof val === 'string' || isArray(val) ) {\n            return !val.length;\n        } else if ( typeof val === 'object' ) {\n            var result = true;\n            forOwn(val, function(){\n                result = false;\n                return false; // break loop\n            });\n            return result;\n        } else {\n            return true;\n        }\n    }\n\n    module.exports = isEmpty;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isFinite.js":"var isNumber = require('./isNumber');\nvar GLOBAL = require('./GLOBAL');\n\n    /**\n     * Check if value is finite\n     */\n    function isFinite(val){\n        var is = false;\n        if (typeof val === 'string' && val !== '') {\n            is = GLOBAL.isFinite( parseFloat(val) );\n        } else if (isNumber(val)){\n            // need to use isNumber because of Number constructor\n            is = GLOBAL.isFinite( val );\n        }\n        return is;\n    }\n\n    module.exports = isFinite;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isNumber.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isNumber(val) {\n        return isKind(val, 'Number');\n    }\n    module.exports = isNumber;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isInteger.js":"var isNumber = require('./isNumber');\n\n    /**\n     * Check if value is an integer\n     */\n    function isInteger(val){\n        return isNumber(val) && (val % 1 === 0);\n    }\n\n    module.exports = isInteger;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isNaN.js":"var isNumber = require('./isNumber');\nvar $isNaN = require('../number/isNaN');\n\n    /**\n     * Check if value is NaN for realz\n     */\n    function isNaN(val){\n        // based on the fact that NaN !== NaN\n        // need to check if it's a number to avoid conflicts with host objects\n        // also need to coerce ToNumber to avoid edge case `new Number(NaN)`\n        return !isNumber(val) || $isNaN(Number(val));\n    }\n\n    module.exports = isNaN;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/isNaN.js":"\n\n    /**\n     * ES6 Number.isNaN\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n     */\n    function isNaN(val){\n        // jshint eqeqeq:false\n        return typeof val === 'number' && val != val;\n    }\n\n    module.exports = isNaN;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isNull.js":"\n    /**\n     */\n    function isNull(val){\n        return val === null;\n    }\n    module.exports = isNull;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isPrimitive.js":"\n\n    /**\n     * Checks if the object is a primitive\n     */\n    function isPrimitive(value) {\n        // Using switch fallthrough because it's simple to read and is\n        // generally fast: http://jsperf.com/testing-value-is-primitive/5\n        switch (typeof value) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n                return true;\n        }\n\n        return value == null;\n    }\n\n    module.exports = isPrimitive;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isRegExp.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isRegExp(val) {\n        return isKind(val, 'RegExp');\n    }\n    module.exports = isRegExp;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isString.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isString(val) {\n        return isKind(val, 'String');\n    }\n    module.exports = isString;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isUndefined.js":"\n    var UNDEF;\n\n    /**\n     */\n    function isUndef(val){\n        return val === UNDEF;\n    }\n    module.exports = isUndef;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/lang/isnt.js":"var is = require('./is');\n\n    /**\n     * Check if both values are not identical/egal\n     */\n    function isnt(x, y){\n        return !is(x, y);\n    }\n\n    module.exports = isnt;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'ceil' : require('./math/ceil'),\n    'clamp' : require('./math/clamp'),\n    'countSteps' : require('./math/countSteps'),\n    'floor' : require('./math/floor'),\n    'inRange' : require('./math/inRange'),\n    'isNear' : require('./math/isNear'),\n    'lerp' : require('./math/lerp'),\n    'loop' : require('./math/loop'),\n    'map' : require('./math/map'),\n    'norm' : require('./math/norm'),\n    'round' : require('./math/round')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/ceil.js":"\n    /**\n     * Round value up with a custom radix.\n     */\n    function ceil(val, step){\n        step = Math.abs(step || 1);\n        return Math.ceil(val / step) * step;\n    }\n\n    module.exports = ceil;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/clamp.js":"\n    /**\n     * Clamps value inside range.\n     */\n    function clamp(val, min, max){\n        return val < min? min : (val > max? max : val);\n    }\n    module.exports = clamp;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/floor.js":"\n    /**\n    * Floor value to full steps.\n    */\n    function floor(val, step){\n        step = Math.abs(step || 1);\n        return Math.floor(val / step) * step;\n    }\n    module.exports = floor;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/inRange.js":"\n    /**\n    * Checks if value is inside the range.\n    */\n    function inRange(val, min, max, threshold){\n        threshold = threshold || 0;\n        return (val + threshold >= min && val - threshold <= max);\n    }\n\n    module.exports = inRange;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/isNear.js":"\n    /**\n    * Check if value is close to target.\n    */\n    function isNear(val, target, threshold){\n        return (Math.abs(val - target) <= threshold);\n    }\n    module.exports = isNear;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/lerp.js":"\n    /**\n    * Linear interpolation.\n    * IMPORTANT:will return `Infinity` if numbers overflow Number.MAX_VALUE\n    */\n    function lerp(ratio, start, end){\n        return start + (end - start) * ratio;\n    }\n\n    module.exports = lerp;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/loop.js":"\n    /**\n    * Loops value inside range.\n    */\n    function loop(val, min, max){\n        return val < min? max : (val > max? min : val);\n    }\n\n    module.exports = loop;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/map.js":"var lerp = require('./lerp');\nvar norm = require('./norm');\n    /**\n    * Maps a number from one scale to another.\n    * @example map(3, 0, 4, -1, 1) -> 0.5\n    */\n    function map(val, min1, max1, min2, max2){\n        return lerp( norm(val, min1, max1), min2, max2 );\n    }\n    module.exports = map;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/norm.js":"\n    /**\n    * Gets normalized ratio of value inside range.\n    */\n    function norm(val, min, max){\n        if (val < min || val > max) {\n            throw new RangeError('value (' + val + ') must be between ' + min + ' and ' + max);\n        }\n\n        return val === max ? 1 : (val - min) / (max - min);\n    }\n    module.exports = norm;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/math/round.js":"\n    /**\n     * Round number to a specific radix\n     */\n    function round(value, radix){\n        radix = radix || 1; // default round 1\n        return Math.round(value / radix) * radix;\n    }\n\n    module.exports = round;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'MAX_INT' : require('./number/MAX_INT'),\n    'MAX_SAFE_INTEGER' : require('./number/MAX_SAFE_INTEGER'),\n    'MAX_UINT' : require('./number/MAX_UINT'),\n    'MIN_INT' : require('./number/MIN_INT'),\n    'abbreviate' : require('./number/abbreviate'),\n    'currencyFormat' : require('./number/currencyFormat'),\n    'enforcePrecision' : require('./number/enforcePrecision'),\n    'isNaN' : require('./number/isNaN'),\n    'nth' : require('./number/nth'),\n    'ordinal' : require('./number/ordinal'),\n    'pad' : require('./number/pad'),\n    'rol' : require('./number/rol'),\n    'ror' : require('./number/ror'),\n    'sign' : require('./number/sign'),\n    'toInt' : require('./number/toInt'),\n    'toUInt' : require('./number/toUInt'),\n    'toUInt31' : require('./number/toUInt31')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/MAX_SAFE_INTEGER.js":"\n\n    // maximum safe integer (Math.pow(2, 53) - 1)\n    // see: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer\n    module.exports = 9007199254740991;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/MAX_UINT.js":"/**\n * @constant Maximum 32-bit unsigned integet value (2^32 - 1)\n */\n\n    module.exports = 4294967295;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/abbreviate.js":"var enforcePrecision = require('./enforcePrecision');\n\n    var _defaultDict = {\n        thousand : 'K',\n        million : 'M',\n        billion : 'B'\n    };\n\n    /**\n     * Abbreviate number if bigger than 1000. (eg: 2.5K, 17.5M, 3.4B, ...)\n     */\n    function abbreviateNumber(val, nDecimals, dict){\n        nDecimals = nDecimals != null? nDecimals : 1;\n        dict = dict || _defaultDict;\n        val = enforcePrecision(val, nDecimals);\n\n        var str, mod;\n\n        if (val < 1000000) {\n            mod = enforcePrecision(val / 1000, nDecimals);\n            // might overflow to next scale during rounding\n            str = mod < 1000? mod + dict.thousand : 1 + dict.million;\n        } else if (val < 1000000000) {\n            mod = enforcePrecision(val / 1000000, nDecimals);\n            str = mod < 1000? mod + dict.million : 1 + dict.billion;\n        } else {\n            str = enforcePrecision(val / 1000000000, nDecimals) + dict.billion;\n        }\n\n        return str;\n    }\n\n    module.exports = abbreviateNumber;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/enforcePrecision.js":"var toNumber = require('../lang/toNumber');\n    /**\n     * Enforce a specific amount of decimal digits and also fix floating\n     * point rounding issues.\n     */\n    function enforcePrecision(val, nDecimalDigits){\n        val = toNumber(val);\n        var pow = Math.pow(10, nDecimalDigits);\n        return +(Math.round(val * pow) / pow).toFixed(nDecimalDigits);\n    }\n    module.exports = enforcePrecision;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/currencyFormat.js":"var toNumber = require('../lang/toNumber');\n\n    /**\n     * Converts number into currency format\n     */\n    function currencyFormat(val, nDecimalDigits, decimalSeparator, thousandsSeparator) {\n        val = toNumber(val);\n        nDecimalDigits = nDecimalDigits == null? 2 : nDecimalDigits;\n        decimalSeparator = decimalSeparator == null? '.' : decimalSeparator;\n        thousandsSeparator = thousandsSeparator == null? ',' : thousandsSeparator;\n\n        //can't use enforce precision since it returns a number and we are\n        //doing a RegExp over the string\n        var fixed = val.toFixed(nDecimalDigits),\n            //separate begin [$1], middle [$2] and decimal digits [$4]\n            parts = new RegExp('^(-?\\\\d{1,3})((?:\\\\d{3})+)(\\\\.(\\\\d{'+ nDecimalDigits +'}))?$').exec( fixed );\n\n        if(parts){ //val >= 1000 || val <= -1000\n            return parts[1] + parts[2].replace(/\\d{3}/g, thousandsSeparator + '$&') + (parts[4] ? decimalSeparator + parts[4] : '');\n        }else{\n            return fixed.replace('.', decimalSeparator);\n        }\n    }\n\n    module.exports = currencyFormat;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/nth.js":"\n\n    /**\n     * Returns \"nth\" of number (1 = \"st\", 2 = \"nd\", 3 = \"rd\", 4..10 = \"th\", ...)\n     */\n    function nth(i) {\n        var t = (i % 100);\n        if (t >= 10 && t <= 20) {\n            return 'th';\n        }\n        switch(i % 10) {\n            case 1:\n                return 'st';\n            case 2:\n                return 'nd';\n            case 3:\n                return 'rd';\n            default:\n                return 'th';\n        }\n    }\n\n    module.exports = nth;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/ordinal.js":"var toInt = require('./toInt');\nvar nth = require('./nth');\n\n    /**\n     * converts number into ordinal form (1st, 2nd, 3rd, 4th, ...)\n     */\n    function ordinal(n){\n       n = toInt(n);\n       return n + nth(n);\n    }\n\n    module.exports = ordinal;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/rol.js":"\n    /**\n     * Bitwise circular shift left\n     * http://en.wikipedia.org/wiki/Circular_shift\n     */\n    function rol(val, shift){\n        return (val << shift) | (val >> (32 - shift));\n    }\n    module.exports = rol;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/ror.js":"\n    /**\n     * Bitwise circular shift right\n     * http://en.wikipedia.org/wiki/Circular_shift\n     */\n    function ror(val, shift){\n        return (val >> shift) | (val << (32 - shift));\n    }\n    module.exports = ror;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/sign.js":"var toNumber = require('../lang/toNumber');\n\n    /**\n     * Get sign of the value.\n     */\n    function sign(val) {\n        var num = toNumber(val);\n        if (num === 0) return num; // +0 and +0 === 0\n        if (isNaN(num)) return num; // NaN\n        return num < 0? -1 : 1;\n    }\n\n    module.exports = sign;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/toUInt.js":"\n\n    /**\n     * \"Convert\" value into a 32-bit unsigned integer.\n     * IMPORTANT: Value will wrap at 2^32.\n     */\n    function toUInt(val){\n        // we do not use lang/toNumber because of perf and also because it\n        // doesn't break the functionality\n        return val >>> 0;\n    }\n\n    module.exports = toUInt;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/number/toUInt31.js":"var MAX_INT = require('./MAX_INT');\n\n    /**\n     * \"Convert\" value into an 31-bit unsigned integer (since 1 bit is used for sign).\n     * IMPORTANT: value wil wrap at 2^31, if negative will return 0.\n     */\n    function toUInt31(val){\n        // we do not use lang/toNumber because of perf and also because it\n        // doesn't break the functionality\n        return (val <= 0)? 0 : (val > MAX_INT? ~~(val % (MAX_INT + 1)) : ~~val);\n    }\n\n    module.exports = toUInt31;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'bindAll' : require('./object/bindAll'),\n    'contains' : require('./object/contains'),\n    'deepFillIn' : require('./object/deepFillIn'),\n    'deepMatches' : require('./object/deepMatches'),\n    'deepMixIn' : require('./object/deepMixIn'),\n    'equals' : require('./object/equals'),\n    'every' : require('./object/every'),\n    'fillIn' : require('./object/fillIn'),\n    'filter' : require('./object/filter'),\n    'find' : require('./object/find'),\n    'flatten' : require('./object/flatten'),\n    'forIn' : require('./object/forIn'),\n    'forOwn' : require('./object/forOwn'),\n    'functions' : require('./object/functions'),\n    'get' : require('./object/get'),\n    'has' : require('./object/has'),\n    'hasOwn' : require('./object/hasOwn'),\n    'keys' : require('./object/keys'),\n    'map' : require('./object/map'),\n    'matches' : require('./object/matches'),\n    'max' : require('./object/max'),\n    'merge' : require('./object/merge'),\n    'min' : require('./object/min'),\n    'mixIn' : require('./object/mixIn'),\n    'namespace' : require('./object/namespace'),\n    'omit' : require('./object/omit'),\n    'pick' : require('./object/pick'),\n    'pluck' : require('./object/pluck'),\n    'reduce' : require('./object/reduce'),\n    'reject' : require('./object/reject'),\n    'result' : require('./object/result'),\n    'set' : require('./object/set'),\n    'size' : require('./object/size'),\n    'some' : require('./object/some'),\n    'unset' : require('./object/unset'),\n    'values' : require('./object/values')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/bindAll.js":"var functions = require('./functions');\nvar bind = require('../function/bind');\nvar forEach = require('../array/forEach');\nvar slice = require('../array/slice');\n\n    /**\n     * Binds methods of the object to be run in it's own context.\n     */\n    function bindAll(obj, rest_methodNames){\n        var keys = arguments.length > 1?\n                    slice(arguments, 1) : functions(obj);\n        forEach(keys, function(key){\n            obj[key] = bind(obj[key], obj);\n        });\n    }\n\n    module.exports = bindAll;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/functions.js":"var forIn = require('./forIn');\n\n    /**\n     * return a list of all enumerable properties that have function values\n     */\n    function functions(obj){\n        var keys = [];\n        forIn(obj, function(val, key){\n            if (typeof val === 'function'){\n                keys.push(key);\n            }\n        });\n        return keys.sort();\n    }\n\n    module.exports = functions;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/deepFillIn.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /**\n     * Deeply copy missing properties in the target from the defaults.\n     */\n    function deepFillIn(target, defaults){\n        var i = 0,\n            n = arguments.length,\n            obj;\n\n        while(++i < n) {\n            obj = arguments[i];\n            if (obj) {\n                // jshint loopfunc: true\n                forOwn(obj, function(newValue, key) {\n                    var curValue = target[key];\n                    if (curValue == null) {\n                        target[key] = newValue;\n                    } else if (isPlainObject(curValue) &&\n                               isPlainObject(newValue)) {\n                        deepFillIn(curValue, newValue);\n                    }\n                });\n            }\n        }\n\n        return target;\n    }\n\n    module.exports = deepFillIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/deepMixIn.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /**\n     * Mixes objects into the target object, recursively mixing existing child\n     * objects.\n     */\n    function deepMixIn(target, objects) {\n        var i = 0,\n            n = arguments.length,\n            obj;\n\n        while(++i < n){\n            obj = arguments[i];\n            if (obj) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n\n        return target;\n    }\n\n    function copyProp(val, key) {\n        var existing = this[key];\n        if (isPlainObject(val) && isPlainObject(existing)) {\n            deepMixIn(existing, val);\n        } else {\n            this[key] = val;\n        }\n    }\n\n    module.exports = deepMixIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/fillIn.js":"var forEach = require('../array/forEach');\nvar slice = require('../array/slice');\nvar forOwn = require('./forOwn');\n\n    /**\n     * Copy missing properties in the obj from the defaults.\n     */\n    function fillIn(obj, var_defaults){\n        forEach(slice(arguments, 1), function(base){\n            forOwn(base, function(val, key){\n                if (obj[key] == null) {\n                    obj[key] = val;\n                }\n            });\n        });\n        return obj;\n    }\n\n    module.exports = fillIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/filter.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Creates a new object with all the properties where the callback returns\n     * true.\n     */\n    function filterValues(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var output = {};\n        forOwn(obj, function(value, key, obj) {\n            if (callback(value, key, obj)) {\n                output[key] = value;\n            }\n        });\n\n        return output;\n    }\n    module.exports = filterValues;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/flatten.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /*\n     * Helper function to flatten to a destination object.\n     * Used to remove the need to create intermediate objects while flattening.\n     */\n    function flattenTo(obj, result, prefix, level) {\n        forOwn(obj, function (value, key) {\n            var nestedPrefix = prefix ? prefix + '.' + key : key;\n\n            if (level !== 0 && isPlainObject(value)) {\n                flattenTo(value, result, nestedPrefix, level - 1);\n            } else {\n                result[nestedPrefix] = value;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Recursively flattens an object.\n     * A new object containing all the elements is returned.\n     * If level is specified, it will only flatten up to that level.\n     */\n    function flatten(obj, level) {\n        if (obj == null) {\n            return {};\n        }\n\n        level = level == null ? -1 : level;\n        return flattenTo(obj, {}, '', level);\n    }\n\n    module.exports = flatten;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/get.js":"var isPrimitive = require('../lang/isPrimitive');\n\n    /**\n     * get \"nested\" object property\n     */\n    function get(obj, prop){\n        var parts = prop.split('.'),\n            last = parts.pop();\n\n        while (prop = parts.shift()) {\n            obj = obj[prop];\n            if (obj == null) return;\n        }\n\n        return obj[last];\n    }\n\n    module.exports = get;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/has.js":"var get = require('./get');\n\n    var UNDEF;\n\n    /**\n     * Check if object has nested property.\n     */\n    function has(obj, prop){\n        return get(obj, prop) !== UNDEF;\n    }\n\n    module.exports = has;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/keys.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object keys\n     */\n     var keys = Object.keys || function (obj) {\n            var keys = [];\n            forOwn(obj, function(val, key){\n                keys.push(key);\n            });\n            return keys;\n        };\n\n    module.exports = keys;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/map.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Creates a new object where all the values are the result of calling\n     * `callback`.\n     */\n    function mapValues(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var output = {};\n        forOwn(obj, function(val, key, obj) {\n            output[key] = callback(val, key, obj);\n        });\n\n        return output;\n    }\n    module.exports = mapValues;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/matches.js":"var forOwn = require('./forOwn');\n\n    /**\n     * checks if a object contains all given properties/values\n     */\n    function matches(target, props){\n        // can't use \"object/every\" because of circular dependency\n        var result = true;\n        forOwn(props, function(val, key){\n            if (target[key] !== val) {\n                // break loop at first difference\n                return (result = false);\n            }\n        });\n        return result;\n    }\n\n    module.exports = matches;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/merge.js":"var hasOwn = require('./hasOwn');\nvar deepClone = require('../lang/deepClone');\nvar isObject = require('../lang/isObject');\n\n    /**\n     * Deep merge objects.\n     */\n    function merge() {\n        var i = 1,\n            key, val, obj, target;\n\n        // make sure we don't modify source element and it's properties\n        // objects are passed by reference\n        target = deepClone( arguments[0] );\n\n        while (obj = arguments[i++]) {\n            for (key in obj) {\n                if ( ! hasOwn(obj, key) ) {\n                    continue;\n                }\n\n                val = obj[key];\n\n                if ( isObject(val) && isObject(target[key]) ){\n                    // inception, deep merge objects\n                    target[key] = merge(target[key], val);\n                } else {\n                    // make sure arrays, regexp, date, objects are cloned\n                    target[key] = deepClone(val);\n                }\n\n            }\n        }\n\n        return target;\n    }\n\n    module.exports = merge;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/namespace.js":"var forEach = require('../array/forEach');\n\n    /**\n     * Create nested object if non-existent\n     */\n    function namespace(obj, path){\n        if (!path) return obj;\n        forEach(path.split('.'), function(key){\n            if (!obj[key]) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        });\n        return obj;\n    }\n\n    module.exports = namespace;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/omit.js":"var slice = require('../array/slice');\nvar contains = require('../array/contains');\n\n    /**\n     * Return a copy of the object, filtered to only contain properties except the blacklisted keys.\n     */\n    function omit(obj, var_keys){\n        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),\n            out = {};\n\n        for (var property in obj) {\n            if (obj.hasOwnProperty(property) && !contains(keys, property)) {\n                out[property] = obj[property];\n            }\n        }\n        return out;\n    }\n\n    module.exports = omit;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/pick.js":"var slice = require('../array/slice');\n\n    /**\n     * Return a copy of the object, filtered to only have values for the whitelisted keys.\n     */\n    function pick(obj, var_keys){\n        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),\n            out = {},\n            i = 0, key;\n        while (key = keys[i++]) {\n            out[key] = obj[key];\n        }\n        return out;\n    }\n\n    module.exports = pick;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/pluck.js":"var map = require('./map');\nvar prop = require('../function/prop');\n\n    /**\n     * Extract a list of property values.\n     */\n    function pluck(obj, propName){\n        return map(obj, prop(propName));\n    }\n\n    module.exports = pluck;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/reject.js":"var filter = require('./filter');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object reject\n     */\n    function reject(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        return filter(obj, function(value, index, obj) {\n            return !callback(value, index, obj);\n        }, thisObj);\n    }\n\n    module.exports = reject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/result.js":"var isFunction = require('../lang/isFunction');\n\n    function result(obj, prop) {\n        var property = obj[prop];\n\n        if(property === undefined) {\n            return;\n        }\n\n        return isFunction(property) ? property.call(obj) : property;\n    }\n\n    module.exports = result;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/set.js":"var namespace = require('./namespace');\n\n    /**\n     * set \"nested\" object property\n     */\n    function set(obj, prop, val){\n        var parts = (/^(.+)\\.(.+)$/).exec(prop);\n        if (parts){\n            namespace(obj, parts[1])[parts[2]] = val;\n        } else {\n            obj[prop] = val;\n        }\n    }\n\n    module.exports = set;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/object/unset.js":"var has = require('./has');\n\n    /**\n     * Unset object property.\n     */\n    function unset(obj, prop){\n        if (has(obj, prop)) {\n            var parts = prop.split('.'),\n                last = parts.pop();\n            while (prop = parts.shift()) {\n                obj = obj[prop];\n            }\n            return (delete obj[last]);\n\n        } else {\n            // if property doesn't exist treat as deleted\n            return true;\n        }\n    }\n\n    module.exports = unset;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'contains' : require('./queryString/contains'),\n    'decode' : require('./queryString/decode'),\n    'encode' : require('./queryString/encode'),\n    'getParam' : require('./queryString/getParam'),\n    'getQuery' : require('./queryString/getQuery'),\n    'parse' : require('./queryString/parse'),\n    'setParam' : require('./queryString/setParam')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/contains.js":"var getQuery = require('./getQuery');\n\n    /**\n     * Checks if query string contains parameter.\n     */\n    function contains(url, paramName) {\n        var regex = new RegExp('(\\\\?|&)'+ paramName +'=', 'g'); //matches `?param=` or `&param=`\n        return regex.test(getQuery(url));\n    }\n\n    module.exports = contains;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/getQuery.js":"\n\n    /**\n     * Gets full query as string with all special chars decoded.\n     */\n    function getQuery(url) {\n        url = url.replace(/#.*/, ''); //removes hash (to avoid getting hash query)\n        var queryString = /\\?[a-zA-Z0-9\\=\\&\\%\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)\\,]+/.exec(url); //valid chars according to: http://www.ietf.org/rfc/rfc1738.txt\n        return (queryString)? decodeURIComponent(queryString[0].replace(/\\+/g,' ')) : '';\n    }\n\n    module.exports = getQuery;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/decode.js":"var typecast = require('../string/typecast');\nvar isArray = require('../lang/isArray');\nvar hasOwn = require('../object/hasOwn');\n\n    /**\n     * Decode query string into an object of keys => vals.\n     */\n    function decode(queryStr, shouldTypecast) {\n        var queryArr = (queryStr || '').replace('?', '').split('&'),\n            reg = /([^=]+)=(.+)/,\n            i = -1,\n            obj = {},\n            equalIndex, cur, pValue, pName;\n\n        while ((cur = queryArr[++i])) {\n            equalIndex = cur.indexOf('=');\n            pName = cur.substring(0, equalIndex);\n            pValue = decodeURIComponent(cur.substring(equalIndex + 1));\n            if (shouldTypecast !== false) {\n                pValue = typecast(pValue);\n            }\n            if (hasOwn(obj, pName)){\n                if(isArray(obj[pName])){\n                    obj[pName].push(pValue);\n                } else {\n                    obj[pName] = [obj[pName], pValue];\n                }\n            } else {\n                obj[pName] = pValue;\n           }\n        }\n        return obj;\n    }\n\n    module.exports = decode;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/typecast.js":"\n\n    var UNDEF;\n\n    /**\n     * Parses string and convert it into a native value.\n     */\n    function typecast(val) {\n        var r;\n        if ( val === null || val === 'null' ) {\n            r = null;\n        } else if ( val === 'true' ) {\n            r = true;\n        } else if ( val === 'false' ) {\n            r = false;\n        } else if ( val === UNDEF || val === 'undefined' ) {\n            r = UNDEF;\n        } else if ( val === '' || isNaN(val) ) {\n            //isNaN('') returns false\n            r = val;\n        } else {\n            //parseFloat(null || '') returns NaN\n            r = parseFloat(val);\n        }\n        return r;\n    }\n\n    module.exports = typecast;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/encode.js":"var forOwn = require('../object/forOwn');\nvar isArray = require('../lang/isArray');\nvar forEach = require('../array/forEach');\n\n    /**\n     * Encode object into a query string.\n     */\n    function encode(obj){\n        var query = [],\n            arrValues, reg;\n        forOwn(obj, function (val, key) {\n            if (isArray(val)) {\n                arrValues = key + '=';\n                reg = new RegExp('&'+key+'+=$');\n                forEach(val, function (aValue) {\n                    arrValues += encodeURIComponent(aValue) + '&' + key + '=';\n                });\n                query.push(arrValues.replace(reg, ''));\n            } else {\n               query.push(key + '=' + encodeURIComponent(val));\n            }\n        });\n        return (query.length) ? '?' + query.join('&') : '';\n    }\n\n    module.exports = encode;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/getParam.js":"var typecast = require('../string/typecast');\nvar getQuery = require('./getQuery');\n\n    /**\n     * Get query parameter value.\n     */\n    function getParam(url, param, shouldTypecast){\n        var regexp = new RegExp('(\\\\?|&)'+ param + '=([^&]*)'), //matches `?param=value` or `&param=value`, value = $2\n            result = regexp.exec( getQuery(url) ),\n            val = (result && result[2])? result[2] : null;\n        return shouldTypecast === false? val : typecast(val);\n    }\n\n    module.exports = getParam;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/parse.js":"var decode = require('./decode');\nvar getQuery = require('./getQuery');\n\n    /**\n     * Get query string, parses and decodes it.\n     */\n    function parse(url, shouldTypecast) {\n        return decode(getQuery(url), shouldTypecast);\n    }\n\n    module.exports = parse;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/queryString/setParam.js":"\n\n    /**\n     * Set query string parameter value\n     */\n    function setParam(url, paramName, value){\n        url = url || '';\n\n        var re = new RegExp('(\\\\?|&)'+ paramName +'=[^&]*' );\n        var param = paramName +'='+ encodeURIComponent( value );\n\n        if ( re.test(url) ) {\n            return url.replace(re, '$1'+ param);\n        } else {\n            if (url.indexOf('?') === -1) {\n                url += '?';\n            }\n            if (url.indexOf('=') !== -1) {\n                url += '&';\n            }\n            return url + param;\n        }\n\n    }\n\n    module.exports = setParam;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'choice' : require('./random/choice'),\n    'guid' : require('./random/guid'),\n    'rand' : require('./random/rand'),\n    'randBit' : require('./random/randBit'),\n    'randBool' : require('./random/randBool'),\n    'randHex' : require('./random/randHex'),\n    'randInt' : require('./random/randInt'),\n    'randSign' : require('./random/randSign'),\n    'randString' : require('./random/randString'),\n    'random' : require('./random/random')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/choice.js":"var randInt = require('./randInt');\nvar isArray = require('../lang/isArray');\n\n    /**\n     * Returns a random element from the supplied arguments\n     * or from the array (if single argument is an array).\n     */\n    function choice(items) {\n        var target = (arguments.length === 1 && isArray(items))? items : arguments;\n        return target[ randInt(0, target.length - 1) ];\n    }\n\n    module.exports = choice;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/guid.js":"var randHex = require('./randHex');\nvar choice = require('./choice');\n\n  /**\n   * Returns pseudo-random guid (UUID v4)\n   * IMPORTANT: it's not totally \"safe\" since randHex/choice uses Math.random\n   * by default and sequences can be predicted in some cases. See the\n   * \"random/random\" documentation for more info about it and how to replace\n   * the default PRNG.\n   */\n  function guid() {\n    return (\n        randHex(8)+'-'+\n        randHex(4)+'-'+\n        // v4 UUID always contain \"4\" at this position to specify it was\n        // randomly generated\n        '4' + randHex(3) +'-'+\n        // v4 UUID always contain chars [a,b,8,9] at this position\n        choice(8, 9, 'a', 'b') + randHex(3)+'-'+\n        randHex(12)\n    );\n  }\n  module.exports = guid;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randHex.js":"var choice = require('./choice');\n\n    var _chars = '0123456789abcdef'.split('');\n\n    /**\n     * Returns a random hexadecimal string\n     */\n    function randHex(size){\n        size = size && size > 0? size : 6;\n        var str = '';\n        while (size--) {\n            str += choice(_chars);\n        }\n        return str;\n    }\n\n    module.exports = randHex;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randBit.js":"var randBool = require('./randBool');\n\n    /**\n     * Returns random bit (0 or 1)\n     */\n    function randomBit() {\n        return randBool()? 1 : 0;\n    }\n\n    module.exports = randomBit;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randBool.js":"var random = require('./random');\n\n    /**\n     * returns a random boolean value (true or false)\n     */\n    function randBool(){\n        return random() >= 0.5;\n    }\n\n    module.exports = randBool;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randSign.js":"var randBool = require('./randBool');\n\n    /**\n     * Returns random sign (-1 or 1)\n     */\n    function randomSign() {\n        return randBool()? 1 : -1;\n    }\n\n    module.exports = randomSign;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/random/randString.js":"var isNumber = require('../lang/isNumber');\nvar isString = require('../lang/isString');\nvar randInt = require('./randInt');\n\n    var defaultDictionary = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    function randomString(length, dictionary) {\n        if(!isNumber(length) || length <= 0) {\n          length = 8;\n        }\n\n        if(!isString(dictionary) || dictionary.length < 1) {\n          dictionary = defaultDictionary;\n        }\n\n        var result = '',\n            domain = dictionary.length - 1;\n\n        while(length--) {\n          result += dictionary[randInt(0, domain)];\n        }\n        \n        return result;\n    }\n\n    module.exports = randomString;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'WHITE_SPACES' : require('./string/WHITE_SPACES'),\n    'camelCase' : require('./string/camelCase'),\n    'contains' : require('./string/contains'),\n    'crop' : require('./string/crop'),\n    'endsWith' : require('./string/endsWith'),\n    'escapeHtml' : require('./string/escapeHtml'),\n    'escapeRegExp' : require('./string/escapeRegExp'),\n    'escapeUnicode' : require('./string/escapeUnicode'),\n    'hyphenate' : require('./string/hyphenate'),\n    'insert' : require('./string/insert'),\n    'interpolate' : require('./string/interpolate'),\n    'lowerCase' : require('./string/lowerCase'),\n    'lpad' : require('./string/lpad'),\n    'ltrim' : require('./string/ltrim'),\n    'makePath' : require('./string/makePath'),\n    'normalizeLineBreaks' : require('./string/normalizeLineBreaks'),\n    'pascalCase' : require('./string/pascalCase'),\n    'properCase' : require('./string/properCase'),\n    'removeNonASCII' : require('./string/removeNonASCII'),\n    'removeNonWord' : require('./string/removeNonWord'),\n    'repeat' : require('./string/repeat'),\n    'replace' : require('./string/replace'),\n    'replaceAccents' : require('./string/replaceAccents'),\n    'rpad' : require('./string/rpad'),\n    'rtrim' : require('./string/rtrim'),\n    'sentenceCase' : require('./string/sentenceCase'),\n    'slugify' : require('./string/slugify'),\n    'startsWith' : require('./string/startsWith'),\n    'stripHtmlTags' : require('./string/stripHtmlTags'),\n    'trim' : require('./string/trim'),\n    'truncate' : require('./string/truncate'),\n    'typecast' : require('./string/typecast'),\n    'unCamelCase' : require('./string/unCamelCase'),\n    'underscore' : require('./string/underscore'),\n    'unescapeHtml' : require('./string/unescapeHtml'),\n    'unescapeUnicode' : require('./string/unescapeUnicode'),\n    'unhyphenate' : require('./string/unhyphenate'),\n    'upperCase' : require('./string/upperCase')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/WHITE_SPACES.js":"\n    /**\n     * Contains all Unicode white-spaces. Taken from\n     * http://en.wikipedia.org/wiki/Whitespace_character.\n     */\n    module.exports = [\n        ' ', '\\n', '\\r', '\\t', '\\f', '\\v', '\\u00A0', '\\u1680', '\\u180E',\n        '\\u2000', '\\u2001', '\\u2002', '\\u2003', '\\u2004', '\\u2005', '\\u2006',\n        '\\u2007', '\\u2008', '\\u2009', '\\u200A', '\\u2028', '\\u2029', '\\u202F',\n        '\\u205F', '\\u3000'\n    ];\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/camelCase.js":"var toString = require('../lang/toString');\nvar replaceAccents = require('./replaceAccents');\nvar removeNonWord = require('./removeNonWord');\nvar upperCase = require('./upperCase');\nvar lowerCase = require('./lowerCase');\n    /**\n    * Convert string to camelCase text.\n    */\n    function camelCase(str){\n        str = toString(str);\n        str = replaceAccents(str);\n        str = removeNonWord(str)\n            .replace(/[\\-_]/g, ' ') //convert all hyphens and underscores to spaces\n            .replace(/\\s[a-z]/g, upperCase) //convert first char of each word to UPPERCASE\n            .replace(/\\s+/g, '') //remove spaces\n            .replace(/^[A-Z]/g, lowerCase); //convert first char to lowercase\n        return str;\n    }\n    module.exports = camelCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/replaceAccents.js":"var toString = require('../lang/toString');\n    /**\n    * Replaces all accented chars with regular ones\n    */\n    function replaceAccents(str){\n        str = toString(str);\n\n        // verifies if the String has accents and replace them\n        if (str.search(/[\\xC0-\\xFF]/g) > -1) {\n            str = str\n                    .replace(/[\\xC0-\\xC5]/g, \"A\")\n                    .replace(/[\\xC6]/g, \"AE\")\n                    .replace(/[\\xC7]/g, \"C\")\n                    .replace(/[\\xC8-\\xCB]/g, \"E\")\n                    .replace(/[\\xCC-\\xCF]/g, \"I\")\n                    .replace(/[\\xD0]/g, \"D\")\n                    .replace(/[\\xD1]/g, \"N\")\n                    .replace(/[\\xD2-\\xD6\\xD8]/g, \"O\")\n                    .replace(/[\\xD9-\\xDC]/g, \"U\")\n                    .replace(/[\\xDD]/g, \"Y\")\n                    .replace(/[\\xDE]/g, \"P\")\n                    .replace(/[\\xE0-\\xE5]/g, \"a\")\n                    .replace(/[\\xE6]/g, \"ae\")\n                    .replace(/[\\xE7]/g, \"c\")\n                    .replace(/[\\xE8-\\xEB]/g, \"e\")\n                    .replace(/[\\xEC-\\xEF]/g, \"i\")\n                    .replace(/[\\xF1]/g, \"n\")\n                    .replace(/[\\xF2-\\xF6\\xF8]/g, \"o\")\n                    .replace(/[\\xF9-\\xFC]/g, \"u\")\n                    .replace(/[\\xFE]/g, \"p\")\n                    .replace(/[\\xFD\\xFF]/g, \"y\");\n        }\n        return str;\n    }\n    module.exports = replaceAccents;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/removeNonWord.js":"var toString = require('../lang/toString');\n    // This pattern is generated by the _build/pattern-removeNonWord.js script\n    var PATTERN = /[^\\x20\\x2D0-9A-Z\\x5Fa-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF]/g;\n\n    /**\n     * Remove non-word chars.\n     */\n    function removeNonWord(str){\n        str = toString(str);\n        return str.replace(PATTERN, '');\n    }\n\n    module.exports = removeNonWord;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/upperCase.js":"var toString = require('../lang/toString');\n    /**\n     * \"Safer\" String.toUpperCase()\n     */\n    function upperCase(str){\n        str = toString(str);\n        return str.toUpperCase();\n    }\n    module.exports = upperCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/lowerCase.js":"var toString = require('../lang/toString');\n    /**\n     * \"Safer\" String.toLowerCase()\n     */\n    function lowerCase(str){\n        str = toString(str);\n        return str.toLowerCase();\n    }\n\n    module.exports = lowerCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/contains.js":"var toString = require('../lang/toString');\n\n    /**\n     * Searches for a given substring\n     */\n    function contains(str, substring, fromIndex){\n        str = toString(str);\n        substring = toString(substring);\n        return str.indexOf(substring, fromIndex) !== -1;\n    }\n\n    module.exports = contains;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/crop.js":"var toString = require('../lang/toString');\nvar truncate = require('./truncate');\n    /**\n     * Truncate string at full words.\n     */\n     function crop(str, maxChars, append) {\n         str = toString(str);\n         return truncate(str, maxChars, append, true);\n     }\n\n     module.exports = crop;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/truncate.js":"var toString = require('../lang/toString');\nvar trim = require('./trim');\n    /**\n     * Limit number of chars.\n     */\n    function truncate(str, maxChars, append, onlyFullWords){\n        str = toString(str);\n        append = append || '...';\n        maxChars = onlyFullWords? maxChars + 1 : maxChars;\n\n        str = trim(str);\n        if(str.length <= maxChars){\n            return str;\n        }\n        str = str.substr(0, maxChars - append.length);\n        //crop at last space or remove trailing whitespace\n        str = onlyFullWords? str.substr(0, str.lastIndexOf(' ')) : trim(str);\n        return str + append;\n    }\n    module.exports = truncate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/trim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\nvar ltrim = require('./ltrim');\nvar rtrim = require('./rtrim');\n    /**\n     * Remove white-spaces from beginning and end of string.\n     */\n    function trim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n        return ltrim(rtrim(str, chars), chars);\n    }\n\n    module.exports = trim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/ltrim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\n    /**\n     * Remove chars from beginning of string.\n     */\n    function ltrim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n\n        var start = 0,\n            len = str.length,\n            charLen = chars.length,\n            found = true,\n            i, c;\n\n        while (found && start < len) {\n            found = false;\n            i = -1;\n            c = str.charAt(start);\n\n            while (++i < charLen) {\n                if (c === chars[i]) {\n                    found = true;\n                    start++;\n                    break;\n                }\n            }\n        }\n\n        return (start >= len) ? '' : str.substr(start, len);\n    }\n\n    module.exports = ltrim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/rtrim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\n    /**\n     * Remove chars from end of string.\n     */\n    function rtrim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n\n        var end = str.length - 1,\n            charLen = chars.length,\n            found = true,\n            i, c;\n\n        while (found && end >= 0) {\n            found = false;\n            i = -1;\n            c = str.charAt(end);\n\n            while (++i < charLen) {\n                if (c === chars[i]) {\n                    found = true;\n                    end--;\n                    break;\n                }\n            }\n        }\n\n        return (end >= 0) ? str.substring(0, end + 1) : '';\n    }\n\n    module.exports = rtrim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/endsWith.js":"var toString = require('../lang/toString');\n    /**\n     * Checks if string ends with specified suffix.\n     */\n    function endsWith(str, suffix) {\n        str = toString(str);\n        suffix = toString(suffix);\n\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n\n    module.exports = endsWith;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/escapeHtml.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escapes a string for insertion into HTML.\n     */\n    function escapeHtml(str){\n        str = toString(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/'/g, '&#39;')\n            .replace(/\"/g, '&quot;');\n        return str;\n    }\n\n    module.exports = escapeHtml;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/escapeRegExp.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escape RegExp string chars.\n     */\n    function escapeRegExp(str) {\n        return toString(str).replace(/\\W/g,'\\\\$&');\n    }\n\n    module.exports = escapeRegExp;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/escapeUnicode.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escape string into unicode sequences\n     */\n    function escapeUnicode(str, shouldEscapePrintable){\n        str = toString(str);\n        return str.replace(/[\\s\\S]/g, function(ch){\n            // skip printable ASCII chars if we should not escape them\n            if (!shouldEscapePrintable && (/[\\x20-\\x7E]/).test(ch)) {\n                return ch;\n            }\n            // we use \"000\" and slice(-4) for brevity, need to pad zeros,\n            // unicode escape always have 4 chars after \"\\u\"\n            return '\\\\u'+ ('000'+ ch.charCodeAt(0).toString(16)).slice(-4);\n        });\n    }\n\n    module.exports = escapeUnicode;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/hyphenate.js":"var toString = require('../lang/toString');\nvar slugify = require('./slugify');\nvar unCamelCase = require('./unCamelCase');\n    /**\n     * Replaces spaces with hyphens, split camelCase text, remove non-word chars, remove accents and convert to lower case.\n     */\n    function hyphenate(str){\n        str = toString(str);\n        str = unCamelCase(str);\n        return slugify(str, \"-\");\n    }\n\n    module.exports = hyphenate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/slugify.js":"var toString = require('../lang/toString');\nvar replaceAccents = require('./replaceAccents');\nvar removeNonWord = require('./removeNonWord');\nvar trim = require('./trim');\n    /**\n     * Convert to lower case, remove accents, remove non-word chars and\n     * replace spaces with the specified delimeter.\n     * Does not split camelCase text.\n     */\n    function slugify(str, delimeter){\n        str = toString(str);\n\n        if (delimeter == null) {\n            delimeter = \"-\";\n        }\n        str = replaceAccents(str);\n        str = removeNonWord(str);\n        str = trim(str) //should come after removeNonWord\n                .replace(/ +/g, delimeter) //replace spaces with delimeter\n                .toLowerCase();\n        return str;\n    }\n    module.exports = slugify;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/unCamelCase.js":"var toString = require('../lang/toString');\n\n    var CAMEL_CASE_BORDER = /([a-z\\xE0-\\xFF])([A-Z\\xC0\\xDF])/g;\n\n    /**\n     * Add space between camelCase text.\n     */\n    function unCamelCase(str, delimiter){\n        if (delimiter == null) {\n            delimiter = ' ';\n        }\n\n        function join(str, c1, c2) {\n            return c1 + delimiter + c2;\n        }\n\n        str = toString(str);\n        str = str.replace(CAMEL_CASE_BORDER, join);\n        str = str.toLowerCase(); //add space between camelCase text\n        return str;\n    }\n    module.exports = unCamelCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/insert.js":"var clamp = require('../math/clamp');\nvar toString = require('../lang/toString');\n\n    /**\n     * Inserts a string at a given index.\n     */\n    function insert(string, index, partial){\n        string = toString(string);\n\n        if (index < 0) {\n            index = string.length + index;\n        }\n\n        index = clamp(index, 0, string.length);\n\n        return string.substr(0, index) + partial + string.substr(index);\n    }\n\n    module.exports = insert;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/interpolate.js":"var toString = require('../lang/toString');\nvar get = require('../object/get');\n\n    var stache = /\\{\\{([^\\}]+)\\}\\}/g; //mustache-like\n\n    /**\n     * String interpolation\n     */\n    function interpolate(template, replacements, syntax){\n        template = toString(template);\n        var replaceFn = function(match, prop){\n            return toString( get(replacements, prop) );\n        };\n        return template.replace(syntax || stache, replaceFn);\n    }\n\n    module.exports = interpolate;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/makePath.js":"var join = require('../array/join');\nvar slice = require('../array/slice');\n\n    /**\n     * Group arguments as path segments, if any of the args is `null` or an\n     * empty string it will be ignored from resulting path.\n     */\n    function makePath(var_args){\n        var result = join(slice(arguments), '/');\n        // need to disconsider duplicate '/' after protocol (eg: 'http://')\n        return result.replace(/([^:\\/]|^)\\/{2,}/g, '$1/');\n    }\n\n    module.exports = makePath;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/normalizeLineBreaks.js":"var toString = require('../lang/toString');\n\n    /**\n     * Convert line-breaks from DOS/MAC to a single standard (UNIX by default)\n     */\n    function normalizeLineBreaks(str, lineEnd) {\n        str = toString(str);\n        lineEnd = lineEnd || '\\n';\n\n        return str\n            .replace(/\\r\\n/g, lineEnd) // DOS\n            .replace(/\\r/g, lineEnd)   // Mac\n            .replace(/\\n/g, lineEnd);  // Unix\n    }\n\n    module.exports = normalizeLineBreaks;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/pascalCase.js":"var toString = require('../lang/toString');\nvar camelCase = require('./camelCase');\nvar upperCase = require('./upperCase');\n    /**\n     * camelCase + UPPERCASE first char\n     */\n    function pascalCase(str){\n        str = toString(str);\n        return camelCase(str).replace(/^[a-z]/, upperCase);\n    }\n\n    module.exports = pascalCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/properCase.js":"var toString = require('../lang/toString');\nvar lowerCase = require('./lowerCase');\nvar upperCase = require('./upperCase');\n    /**\n     * UPPERCASE first char of each word.\n     */\n    function properCase(str){\n        str = toString(str);\n        return lowerCase(str).replace(/^\\w|\\s\\w/g, upperCase);\n    }\n\n    module.exports = properCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/removeNonASCII.js":"var toString = require('../lang/toString');\n    /**\n     * Remove non-printable ASCII chars\n     */\n    function removeNonASCII(str){\n        str = toString(str);\n\n        // Matches non-printable ASCII chars -\n        // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters\n        return str.replace(/[^\\x20-\\x7E]/g, '');\n    }\n\n    module.exports = removeNonASCII;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/replace.js":"var toString = require('../lang/toString');\nvar toArray = require('../lang/toArray');\n\n    /**\n     * Replace string(s) with the replacement(s) in the source.\n     */\n    function replace(str, search, replacements) {\n        str = toString(str);\n        search = toArray(search);\n        replacements = toArray(replacements);\n\n        var searchLength = search.length,\n            replacementsLength = replacements.length;\n\n        if (replacementsLength !== 1 && searchLength !== replacementsLength) {\n            throw new Error('Unequal number of searches and replacements');\n        }\n\n        var i = -1;\n        while (++i < searchLength) {\n            // Use the first replacement for all searches if only one\n            // replacement is provided\n            str = str.replace(\n                search[i],\n                replacements[(replacementsLength === 1) ? 0 : i]);\n        }\n\n        return str;\n    }\n\n    module.exports = replace;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/rpad.js":"var toString = require('../lang/toString');\nvar repeat = require('./repeat');\n\n    /**\n     * Pad string with `char` if its' length is smaller than `minLen`\n     */\n    function rpad(str, minLen, ch) {\n        str = toString(str);\n        ch = ch || ' ';\n        return (str.length < minLen)? str + repeat(ch, minLen - str.length) : str;\n    }\n\n    module.exports = rpad;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/sentenceCase.js":"var toString = require('../lang/toString');\nvar lowerCase = require('./lowerCase');\nvar upperCase = require('./upperCase');\n    /**\n     * UPPERCASE first char of each sentence and lowercase other chars.\n     */\n    function sentenceCase(str){\n        str = toString(str);\n\n        // Replace first char of each sentence (new line or after '.\\s+') to\n        // UPPERCASE\n        return lowerCase(str).replace(/(^\\w)|\\.\\s+(\\w)/gm, upperCase);\n    }\n    module.exports = sentenceCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/startsWith.js":"var toString = require('../lang/toString');\n    /**\n     * Checks if string starts with specified prefix.\n     */\n    function startsWith(str, prefix) {\n        str = toString(str);\n        prefix = toString(prefix);\n\n        return str.indexOf(prefix) === 0;\n    }\n\n    module.exports = startsWith;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/stripHtmlTags.js":"var toString = require('../lang/toString');\n    /**\n     * Remove HTML tags from string.\n     */\n    function stripHtmlTags(str){\n        str = toString(str);\n\n        return str.replace(/<[^>]*>/g, '');\n    }\n    module.exports = stripHtmlTags;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/underscore.js":"var toString = require('../lang/toString');\nvar slugify = require('./slugify');\nvar unCamelCase = require('./unCamelCase');\n    /**\n     * Replaces spaces with underscores, split camelCase text, remove non-word chars, remove accents and convert to lower case.\n     */\n    function underscore(str){\n        str = toString(str);\n        str = unCamelCase(str);\n        return slugify(str, \"_\");\n    }\n    module.exports = underscore;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/unescapeHtml.js":"var toString = require('../lang/toString');\n\n    /**\n     * Unescapes HTML special chars\n     */\n    function unescapeHtml(str){\n        str = toString(str)\n            .replace(/&amp;/g , '&')\n            .replace(/&lt;/g  , '<')\n            .replace(/&gt;/g  , '>')\n            .replace(/&#0*39;/g , \"'\")\n            .replace(/&quot;/g, '\"');\n        return str;\n    }\n\n    module.exports = unescapeHtml;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/unescapeUnicode.js":"var toString = require('../lang/toString');\n\n    /**\n     * Unescape unicode char sequences\n     */\n    function unescapeUnicode(str){\n        str = toString(str);\n        return str.replace(/\\\\u[0-9a-f]{4}/g, function(ch){\n            var code = parseInt(ch.slice(2), 16);\n            return String.fromCharCode(code);\n        });\n    }\n\n    module.exports = unescapeUnicode;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/string/unhyphenate.js":"var toString = require('../lang/toString');\n    /**\n     * Replaces hyphens with spaces. (only hyphens between word chars)\n     */\n    function unhyphenate(str){\n        str = toString(str);\n        return str.replace(/(\\w)(-)(\\w)/g, '$1 $3');\n    }\n    module.exports = unhyphenate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/time.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'convert' : require('./time/convert'),\n    'now' : require('./time/now'),\n    'parseMs' : require('./time/parseMs'),\n    'toTimeString' : require('./time/toTimeString')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/time/parseMs.js":"var countSteps = require('../math/countSteps');\n\n    /**\n     * Parse timestamp into an object.\n     */\n    function parseMs(ms){\n        return {\n            milliseconds : countSteps(ms, 1, 1000),\n            seconds      : countSteps(ms, 1000, 60),\n            minutes      : countSteps(ms, 60000, 60),\n            hours        : countSteps(ms, 3600000, 24),\n            days         : countSteps(ms, 86400000)\n        };\n    }\n\n    module.exports = parseMs;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mout/time/toTimeString.js":"var countSteps = require('../math/countSteps');\nvar pad = require('../number/pad');\n\n    var HOUR = 3600000,\n        MINUTE = 60000,\n        SECOND = 1000;\n\n    /**\n     * Format timestamp into a time string.\n     */\n    function toTimeString(ms){\n        var h = ms < HOUR   ? 0 : countSteps(ms, HOUR),\n            m = ms < MINUTE ? 0 : countSteps(ms, MINUTE, 60),\n            s = ms < SECOND ? 0 : countSteps(ms, SECOND, 60),\n            str = '';\n\n        str += h? h + ':' : '';\n        str += pad(m, 2) + ':';\n        str += pad(s, 2);\n\n        return str;\n    }\n    module.exports = toTimeString;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/Config.js":"var lang = require('mout/lang');\nvar object = require('mout/object');\nvar rc = require('./util/rc');\nvar expand = require('./util/expand');\nvar EnvProxy = require('./util/proxy');\nvar path = require('path');\nvar fs = require('fs');\n\nfunction Config(cwd) {\n    this._cwd = cwd;\n    this._proxy = new EnvProxy();\n    this._config = {};\n}\n\nConfig.prototype.load = function (overwrites) {\n    this._config = rc('bower', this._cwd);\n\n    this._config = object.merge(\n      expand(this._config || {}),\n      expand(overwrites || {})\n    );\n\n    this._config = normalise(this._config);\n\n    this._proxy.set(this._config);\n\n    return this;\n};\n\nConfig.prototype.restore = function () {\n  this._proxy.restore();\n};\n\nfunction readCertFile(path) {\n    path = path || '';\n\n    var sep = '-----END CERTIFICATE-----';\n\n    var certificates;\n\n    if (path.indexOf(sep) === -1) {\n        certificates = fs.readFileSync(path, { encoding: 'utf8' });\n    } else {\n        certificates = path;\n    }\n\n    return certificates.\n      split(sep).\n      filter(function(s) { return !s.match(/^\\s*$/); }).\n      map(function(s) { return s + sep; });\n}\n\nfunction loadCAs(caConfig) {\n    // If a ca file path has been specified, expand that here to the file's\n    // contents. As a user can specify these individually, we must load them\n    // one by one.\n    for (var p in caConfig) {\n        if (caConfig.hasOwnProperty(p)) {\n            var prop = caConfig[p];\n            if (Array.isArray(prop)) {\n                caConfig[p] = prop.map(function(s) {\n                    return readCertFile(s);\n                });\n            } else if (prop) {\n                caConfig[p] = readCertFile(prop);\n            }\n        }\n    }\n}\n\nConfig.prototype.toObject = function () {\n    return lang.deepClone(this._config);\n};\n\nConfig.create = function (cwd) {\n    return new Config(cwd);\n};\n\nConfig.read = function (cwd, overrides) {\n    var config = Config.create(cwd);\n    return config.load(overrides).toObject();\n};\n\nfunction normalise(config) {\n    config = expand(config);\n\n    // Some backwards compatible things..\n    if (config.shorthandResolver) {\n      config.shorthandResolver = config.shorthandResolver\n        .replace(/\\{\\{\\{/g, '{{')\n        .replace(/\\}\\}\\}/g, '}}');\n    }\n\n    // Ensure that every registry endpoint does not end with /\n    config.registry.search = config.registry.search.map(function (url) {\n        return url.replace(/\\/+$/, '');\n    });\n    config.registry.register = config.registry.register.replace(/\\/+$/, '');\n    config.registry.publish = config.registry.publish.replace(/\\/+$/, '');\n    config.tmp = path.resolve(config.tmp);\n\n    loadCAs(config.ca);\n\n    return config;\n}\n\nConfig.DEFAULT_REGISTRY = require('./util/defaults').registry;\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'GLOBAL' : require('./lang/GLOBAL'),\n    'clone' : require('./lang/clone'),\n    'createObject' : require('./lang/createObject'),\n    'ctorApply' : require('./lang/ctorApply'),\n    'deepClone' : require('./lang/deepClone'),\n    'deepEquals' : require('./lang/deepEquals'),\n    'defaults' : require('./lang/defaults'),\n    'inheritPrototype' : require('./lang/inheritPrototype'),\n    'is' : require('./lang/is'),\n    'isArguments' : require('./lang/isArguments'),\n    'isArray' : require('./lang/isArray'),\n    'isBoolean' : require('./lang/isBoolean'),\n    'isDate' : require('./lang/isDate'),\n    'isEmpty' : require('./lang/isEmpty'),\n    'isFinite' : require('./lang/isFinite'),\n    'isFunction' : require('./lang/isFunction'),\n    'isInteger' : require('./lang/isInteger'),\n    'isKind' : require('./lang/isKind'),\n    'isNaN' : require('./lang/isNaN'),\n    'isNull' : require('./lang/isNull'),\n    'isNumber' : require('./lang/isNumber'),\n    'isObject' : require('./lang/isObject'),\n    'isPlainObject' : require('./lang/isPlainObject'),\n    'isPrimitive' : require('./lang/isPrimitive'),\n    'isRegExp' : require('./lang/isRegExp'),\n    'isString' : require('./lang/isString'),\n    'isUndefined' : require('./lang/isUndefined'),\n    'isnt' : require('./lang/isnt'),\n    'kindOf' : require('./lang/kindOf'),\n    'toArray' : require('./lang/toArray'),\n    'toNumber' : require('./lang/toNumber'),\n    'toString' : require('./lang/toString')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/GLOBAL.js":"\n\n    // Reference to the global context (works on ES3 and ES5-strict mode)\n    //jshint -W061, -W064\n    module.exports = Function('return this')();\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/clone.js":"var kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\nvar mixIn = require('../object/mixIn');\n\n    /**\n     * Clone native types.\n     */\n    function clone(val){\n        switch (kindOf(val)) {\n            case 'Object':\n                return cloneObject(val);\n            case 'Array':\n                return cloneArray(val);\n            case 'RegExp':\n                return cloneRegExp(val);\n            case 'Date':\n                return cloneDate(val);\n            default:\n                return val;\n        }\n    }\n\n    function cloneObject(source) {\n        if (isPlainObject(source)) {\n            return mixIn({}, source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneRegExp(r) {\n        var flags = '';\n        flags += r.multiline ? 'm' : '';\n        flags += r.global ? 'g' : '';\n        flags += r.ignoreCase ? 'i' : '';\n        return new RegExp(r.source, flags);\n    }\n\n    function cloneDate(date) {\n        return new Date(+date);\n    }\n\n    function cloneArray(arr) {\n        return arr.slice();\n    }\n\n    module.exports = clone;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/kindOf.js":"\n\n    var _rKind = /^\\[object (.*)\\]$/,\n        _toString = Object.prototype.toString,\n        UNDEF;\n\n    /**\n     * Gets the \"kind\" of value. (e.g. \"String\", \"Number\", etc)\n     */\n    function kindOf(val) {\n        if (val === null) {\n            return 'Null';\n        } else if (val === UNDEF) {\n            return 'Undefined';\n        } else {\n            return _rKind.exec( _toString.call(val) )[1];\n        }\n    }\n    module.exports = kindOf;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isPlainObject.js":"\n\n    /**\n     * Checks if the value is created by the `Object` constructor.\n     */\n    function isPlainObject(value) {\n        return (!!value && typeof value === 'object' &&\n            value.constructor === Object);\n    }\n\n    module.exports = isPlainObject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/mixIn.js":"var forOwn = require('./forOwn');\n\n    /**\n    * Combine properties from all the objects into first one.\n    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.\n    * @param {object} target    Target Object\n    * @param {...object} objects    Objects to be combined (0...n objects).\n    * @return {object} Target Object.\n    */\n    function mixIn(target, objects){\n        var i = 0,\n            n = arguments.length,\n            obj;\n        while(++i < n){\n            obj = arguments[i];\n            if (obj != null) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n        return target;\n    }\n\n    function copyProp(val, key){\n        this[key] = val;\n    }\n\n    module.exports = mixIn;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/forOwn.js":"var hasOwn = require('./hasOwn');\nvar forIn = require('./forIn');\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forOwn(obj, fn, thisObj){\n        forIn(obj, function(val, key){\n            if (hasOwn(obj, key)) {\n                return fn.call(thisObj, obj[key], key, obj);\n            }\n        });\n    }\n\n    module.exports = forOwn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/hasOwn.js":"\n\n    /**\n     * Safer Object.hasOwnProperty\n     */\n     function hasOwn(obj, prop){\n         return Object.prototype.hasOwnProperty.call(obj, prop);\n     }\n\n     module.exports = hasOwn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/forIn.js":"var hasOwn = require('./hasOwn');\n\n    var _hasDontEnumBug,\n        _dontEnums;\n\n    function checkDontEnum(){\n        _dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ];\n\n        _hasDontEnumBug = true;\n\n        for (var key in {'toString': null}) {\n            _hasDontEnumBug = false;\n        }\n    }\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forIn(obj, fn, thisObj){\n        var key, i = 0;\n        // no need to check if argument is a real object that way we can use\n        // it for arrays, functions, date, etc.\n\n        //post-pone check till needed\n        if (_hasDontEnumBug == null) checkDontEnum();\n\n        for (key in obj) {\n            if (exec(fn, obj, key, thisObj) === false) {\n                break;\n            }\n        }\n\n\n        if (_hasDontEnumBug) {\n            var ctor = obj.constructor,\n                isProto = !!ctor && obj === ctor.prototype;\n\n            while (key = _dontEnums[i++]) {\n                // For constructor, if it is a prototype object the constructor\n                // is always non-enumerable unless defined otherwise (and\n                // enumerated above).  For non-prototype objects, it will have\n                // to be defined on this object, since it cannot be defined on\n                // any prototype objects.\n                //\n                // For other [[DontEnum]] properties, check if the value is\n                // different than Object prototype value.\n                if (\n                    (key !== 'constructor' ||\n                        (!isProto && hasOwn(obj, key))) &&\n                    obj[key] !== Object.prototype[key]\n                ) {\n                    if (exec(fn, obj, key, thisObj) === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function exec(fn, obj, key, thisObj){\n        return fn.call(thisObj, obj[key], key, obj);\n    }\n\n    module.exports = forIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/createObject.js":"var mixIn = require('../object/mixIn');\n\n    /**\n     * Create Object using prototypal inheritance and setting custom properties.\n     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.\n     * @param {object} parent    Parent Object.\n     * @param {object} [props] Object properties.\n     * @return {object} Created object.\n     */\n    function createObject(parent, props){\n        function F(){}\n        F.prototype = parent;\n        return mixIn(new F(), props);\n\n    }\n    module.exports = createObject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/ctorApply.js":"\n\n    function F(){}\n\n    /**\n     * Do fn.apply on a constructor.\n     */\n    function ctorApply(ctor, args) {\n        F.prototype = ctor.prototype;\n        var instance = new F();\n        ctor.apply(instance, args);\n        return instance;\n    }\n\n    module.exports = ctorApply;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/deepClone.js":"var clone = require('./clone');\nvar forOwn = require('../object/forOwn');\nvar kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\n\n    /**\n     * Recursively clone native types.\n     */\n    function deepClone(val, instanceClone) {\n        switch ( kindOf(val) ) {\n            case 'Object':\n                return cloneObject(val, instanceClone);\n            case 'Array':\n                return cloneArray(val, instanceClone);\n            default:\n                return clone(val);\n        }\n    }\n\n    function cloneObject(source, instanceClone) {\n        if (isPlainObject(source)) {\n            var out = {};\n            forOwn(source, function(val, key) {\n                this[key] = deepClone(val, instanceClone);\n            }, out);\n            return out;\n        } else if (instanceClone) {\n            return instanceClone(source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneArray(arr, instanceClone) {\n        var out = [],\n            i = -1,\n            n = arr.length,\n            val;\n        while (++i < n) {\n            out[i] = deepClone(arr[i], instanceClone);\n        }\n        return out;\n    }\n\n    module.exports = deepClone;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/deepEquals.js":"var is = require('./is');\nvar isObject = require('./isObject');\nvar isArray = require('./isArray');\nvar objEquals = require('../object/equals');\nvar arrEquals = require('../array/equals');\n\n    /**\n     * Recursively checks for same properties and values.\n     */\n    function deepEquals(a, b, callback){\n        callback = callback || is;\n\n        var bothObjects = isObject(a) && isObject(b);\n        var bothArrays = !bothObjects && isArray(a) && isArray(b);\n\n        if (!bothObjects && !bothArrays) {\n            return callback(a, b);\n        }\n\n        function compare(a, b){\n            return deepEquals(a, b, callback);\n        }\n\n        var method = bothObjects ? objEquals : arrEquals;\n        return method(a, b, compare);\n    }\n\n    module.exports = deepEquals;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/is.js":"\n\n    /**\n     * Check if both arguments are egal.\n     */\n    function is(x, y){\n        // implementation borrowed from harmony:egal spec\n        if (x === y) {\n          // 0 === -0, but they are not identical\n          return x !== 0 || 1 / x === 1 / y;\n        }\n\n        // NaN !== NaN, but they are identical.\n        // NaNs are the only non-reflexive value, i.e., if x !== x,\n        // then x is a NaN.\n        // isNaN is broken: it converts its argument to number, so\n        // isNaN(\"foo\") => true\n        return x !== x && y !== y;\n    }\n\n    module.exports = is;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isObject.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isObject(val) {\n        return isKind(val, 'Object');\n    }\n    module.exports = isObject;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isKind.js":"var kindOf = require('./kindOf');\n    /**\n     * Check if value is from a specific \"kind\".\n     */\n    function isKind(val, kind){\n        return kindOf(val) === kind;\n    }\n    module.exports = isKind;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isArray.js":"var isKind = require('./isKind');\n    /**\n     */\n    var isArray = Array.isArray || function (val) {\n        return isKind(val, 'Array');\n    };\n    module.exports = isArray;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/equals.js":"var hasOwn = require('./hasOwn');\nvar every = require('./every');\nvar isObject = require('../lang/isObject');\nvar is = require('../lang/is');\n\n    // Makes a function to compare the object values from the specified compare\n    // operation callback.\n    function makeCompare(callback) {\n        return function(value, key) {\n            return hasOwn(this, key) && callback(value, this[key]);\n        };\n    }\n\n    function checkProperties(value, key) {\n        return hasOwn(this, key);\n    }\n\n    /**\n     * Checks if two objects have the same keys and values.\n     */\n    function equals(a, b, callback) {\n        callback = callback || is;\n\n        if (!isObject(a) || !isObject(b)) {\n            return callback(a, b);\n        }\n\n        return (every(a, makeCompare(callback), b) &&\n                every(b, checkProperties, a));\n    }\n\n    module.exports = equals;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/every.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object every\n     */\n    function every(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = true;\n        forOwn(obj, function(val, key) {\n            // we consider any falsy values as \"false\" on purpose so shorthand\n            // syntax can be used to check property existence\n            if (!callback(val, key, obj)) {\n                result = false;\n                return false; // break\n            }\n        });\n        return result;\n    }\n\n    module.exports = every;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/function/makeIterator_.js":"var identity = require('./identity');\nvar prop = require('./prop');\nvar deepMatches = require('../object/deepMatches');\n\n    /**\n     * Converts argument into a valid iterator.\n     * Used internally on most array/object/collection methods that receives a\n     * callback/iterator providing a shortcut syntax.\n     */\n    function makeIterator(src, thisObj){\n        if (src == null) {\n            return identity;\n        }\n        switch(typeof src) {\n            case 'function':\n                // function is the first to improve perf (most common case)\n                // also avoid using `Function#call` if not needed, which boosts\n                // perf a lot in some cases\n                return (typeof thisObj !== 'undefined')? function(val, i, arr){\n                    return src.call(thisObj, val, i, arr);\n                } : src;\n            case 'object':\n                return function(val){\n                    return deepMatches(val, src);\n                };\n            case 'string':\n            case 'number':\n                return prop(src);\n        }\n    }\n\n    module.exports = makeIterator;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/function/identity.js":"\n\n    /**\n     * Returns the first argument provided to it.\n     */\n    function identity(val){\n        return val;\n    }\n\n    module.exports = identity;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/function/prop.js":"\n\n    /**\n     * Returns a function that gets a property of the passed object\n     */\n    function prop(name){\n        return function(obj){\n            return obj[name];\n        };\n    }\n\n    module.exports = prop;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/deepMatches.js":"var forOwn = require('./forOwn');\nvar isArray = require('../lang/isArray');\n\n    function containsMatch(array, pattern) {\n        var i = -1, length = array.length;\n        while (++i < length) {\n            if (deepMatches(array[i], pattern)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function matchArray(target, pattern) {\n        var i = -1, patternLength = pattern.length;\n        while (++i < patternLength) {\n            if (!containsMatch(target, pattern[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function matchObject(target, pattern) {\n        var result = true;\n        forOwn(pattern, function(val, key) {\n            if (!deepMatches(target[key], val)) {\n                // Return false to break out of forOwn early\n                return (result = false);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Recursively check if the objects match.\n     */\n    function deepMatches(target, pattern){\n        if (target && typeof target === 'object' &&\n            pattern && typeof pattern === 'object') {\n            if (isArray(target) && isArray(pattern)) {\n                return matchArray(target, pattern);\n            } else {\n                return matchObject(target, pattern);\n            }\n        } else {\n            return target === pattern;\n        }\n    }\n\n    module.exports = deepMatches;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/equals.js":"var is = require('../lang/is');\nvar isArray = require('../lang/isArray');\nvar every = require('./every');\n\n    /**\n     * Compares if both arrays have the same elements\n     */\n    function equals(a, b, callback){\n        callback = callback || is;\n\n        if (!isArray(a) || !isArray(b)) {\n            return callback(a, b);\n        }\n\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        return every(a, makeCompare(callback), b);\n    }\n\n    function makeCompare(callback) {\n        return function(value, i) {\n            return i in this && callback(value, this[i]);\n        };\n    }\n\n    module.exports = equals;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/every.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array every\n     */\n    function every(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = true;\n        if (arr == null) {\n            return result;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if (!callback(arr[i], i, arr) ) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    module.exports = every;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/defaults.js":"var toArray = require('./toArray');\nvar find = require('../array/find');\n\n    /**\n     * Return first non void argument\n     */\n    function defaults(var_args){\n        return find(toArray(arguments), nonVoid);\n    }\n\n    function nonVoid(val){\n        return val != null;\n    }\n\n    module.exports = defaults;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/toArray.js":"var kindOf = require('./kindOf');\nvar GLOBAL = require('./GLOBAL');\n\n    /**\n     * Convert array-like object into array\n     */\n    function toArray(val){\n        var ret = [],\n            kind = kindOf(val),\n            n;\n\n        if (val != null) {\n            if ( val.length == null || kind === 'String' || kind === 'Function' || kind === 'RegExp' || val === GLOBAL ) {\n                //string, regexp, function have .length but user probably just want\n                //to wrap value into an array..\n                ret[ret.length] = val;\n            } else {\n                //window returns true on isObject in IE7 and may have length\n                //property. `typeof NodeList` returns `function` on Safari so\n                //we can't use it (#58)\n                n = val.length;\n                while (n--) {\n                    ret[n] = val[n];\n                }\n            }\n        }\n        return ret;\n    }\n    module.exports = toArray;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/find.js":"var findIndex = require('./findIndex');\n\n    /**\n     * Returns first item that matches criteria\n     */\n    function find(arr, iterator, thisObj){\n        var idx = findIndex(arr, iterator, thisObj);\n        return idx >= 0? arr[idx] : void(0);\n    }\n\n    module.exports = find;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/findIndex.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Returns the index of the first item that matches criteria\n     */\n    function findIndex(arr, iterator, thisObj){\n        iterator = makeIterator(iterator, thisObj);\n        if (arr == null) {\n            return -1;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            if (iterator(arr[i], i, arr)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    module.exports = findIndex;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/inheritPrototype.js":"var createObject = require('./createObject');\n\n    /**\n    * Inherit prototype from another Object.\n    * - inspired by Nicholas Zackas <http://nczonline.net> Solution\n    * @param {object} child Child object\n    * @param {object} parent    Parent Object\n    */\n    function inheritPrototype(child, parent){\n        var p = createObject(parent.prototype);\n        p.constructor = child;\n        child.prototype = p;\n        child.super_ = parent;\n        return p;\n    }\n\n    module.exports = inheritPrototype;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isArguments.js":"var isKind = require('./isKind');\n\n    /**\n     */\n    var isArgs = isKind(arguments, 'Arguments')?\n            function(val){\n                return isKind(val, 'Arguments');\n            } :\n            function(val){\n                // Arguments is an Object on IE7\n                return !!(val && Object.prototype.hasOwnProperty.call(val, 'callee'));\n            };\n\n    module.exports = isArgs;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isBoolean.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isBoolean(val) {\n        return isKind(val, 'Boolean');\n    }\n    module.exports = isBoolean;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isDate.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isDate(val) {\n        return isKind(val, 'Date');\n    }\n    module.exports = isDate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isEmpty.js":"var forOwn = require('../object/forOwn');\nvar isArray = require('./isArray');\n\n    function isEmpty(val){\n        if (val == null) {\n            // typeof null == 'object' so we check it first\n            return true;\n        } else if ( typeof val === 'string' || isArray(val) ) {\n            return !val.length;\n        } else if ( typeof val === 'object' ) {\n            var result = true;\n            forOwn(val, function(){\n                result = false;\n                return false; // break loop\n            });\n            return result;\n        } else {\n            return true;\n        }\n    }\n\n    module.exports = isEmpty;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isFinite.js":"var isNumber = require('./isNumber');\nvar GLOBAL = require('./GLOBAL');\n\n    /**\n     * Check if value is finite\n     */\n    function isFinite(val){\n        var is = false;\n        if (typeof val === 'string' && val !== '') {\n            is = GLOBAL.isFinite( parseFloat(val) );\n        } else if (isNumber(val)){\n            // need to use isNumber because of Number constructor\n            is = GLOBAL.isFinite( val );\n        }\n        return is;\n    }\n\n    module.exports = isFinite;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isNumber.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isNumber(val) {\n        return isKind(val, 'Number');\n    }\n    module.exports = isNumber;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isFunction.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isFunction(val) {\n        return isKind(val, 'Function');\n    }\n    module.exports = isFunction;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isInteger.js":"var isNumber = require('./isNumber');\n\n    /**\n     * Check if value is an integer\n     */\n    function isInteger(val){\n        return isNumber(val) && (val % 1 === 0);\n    }\n\n    module.exports = isInteger;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isNaN.js":"var isNumber = require('./isNumber');\nvar $isNaN = require('../number/isNaN');\n\n    /**\n     * Check if value is NaN for realz\n     */\n    function isNaN(val){\n        // based on the fact that NaN !== NaN\n        // need to check if it's a number to avoid conflicts with host objects\n        // also need to coerce ToNumber to avoid edge case `new Number(NaN)`\n        return !isNumber(val) || $isNaN(Number(val));\n    }\n\n    module.exports = isNaN;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/number/isNaN.js":"\n\n    /**\n     * ES6 Number.isNaN\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n     */\n    function isNaN(val){\n        // jshint eqeqeq:false\n        return typeof val === 'number' && val != val;\n    }\n\n    module.exports = isNaN;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isNull.js":"\n    /**\n     */\n    function isNull(val){\n        return val === null;\n    }\n    module.exports = isNull;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isPrimitive.js":"\n\n    /**\n     * Checks if the object is a primitive\n     */\n    function isPrimitive(value) {\n        // Using switch fallthrough because it's simple to read and is\n        // generally fast: http://jsperf.com/testing-value-is-primitive/5\n        switch (typeof value) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n                return true;\n        }\n\n        return value == null;\n    }\n\n    module.exports = isPrimitive;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isRegExp.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isRegExp(val) {\n        return isKind(val, 'RegExp');\n    }\n    module.exports = isRegExp;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isString.js":"var isKind = require('./isKind');\n    /**\n     */\n    function isString(val) {\n        return isKind(val, 'String');\n    }\n    module.exports = isString;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isUndefined.js":"\n    var UNDEF;\n\n    /**\n     */\n    function isUndef(val){\n        return val === UNDEF;\n    }\n    module.exports = isUndef;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/isnt.js":"var is = require('./is');\n\n    /**\n     * Check if both values are not identical/egal\n     */\n    function isnt(x, y){\n        return !is(x, y);\n    }\n\n    module.exports = isnt;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/toNumber.js":"var isArray = require('./isArray');\n\n    /**\n     * covert value into number if numeric\n     */\n    function toNumber(val){\n        // numberic values should come first because of -0\n        if (typeof val === 'number') return val;\n        // we want all falsy values (besides -0) to return zero to avoid\n        // headaches\n        if (!val) return 0;\n        if (typeof val === 'string') return parseFloat(val);\n        // arrays are edge cases. `Number([4]) === 4`\n        if (isArray(val)) return NaN;\n        return Number(val);\n    }\n\n    module.exports = toNumber;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/lang/toString.js":"\n\n    /**\n     * Typecast a value to a String, using an empty string value for null or\n     * undefined.\n     */\n    function toString(val){\n        return val == null ? '' : val.toString();\n    }\n\n    module.exports = toString;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'bindAll' : require('./object/bindAll'),\n    'contains' : require('./object/contains'),\n    'deepFillIn' : require('./object/deepFillIn'),\n    'deepMatches' : require('./object/deepMatches'),\n    'deepMixIn' : require('./object/deepMixIn'),\n    'equals' : require('./object/equals'),\n    'every' : require('./object/every'),\n    'fillIn' : require('./object/fillIn'),\n    'filter' : require('./object/filter'),\n    'find' : require('./object/find'),\n    'flatten' : require('./object/flatten'),\n    'forIn' : require('./object/forIn'),\n    'forOwn' : require('./object/forOwn'),\n    'functions' : require('./object/functions'),\n    'get' : require('./object/get'),\n    'has' : require('./object/has'),\n    'hasOwn' : require('./object/hasOwn'),\n    'keys' : require('./object/keys'),\n    'map' : require('./object/map'),\n    'matches' : require('./object/matches'),\n    'max' : require('./object/max'),\n    'merge' : require('./object/merge'),\n    'min' : require('./object/min'),\n    'mixIn' : require('./object/mixIn'),\n    'namespace' : require('./object/namespace'),\n    'omit' : require('./object/omit'),\n    'pick' : require('./object/pick'),\n    'pluck' : require('./object/pluck'),\n    'reduce' : require('./object/reduce'),\n    'reject' : require('./object/reject'),\n    'result' : require('./object/result'),\n    'set' : require('./object/set'),\n    'size' : require('./object/size'),\n    'some' : require('./object/some'),\n    'unset' : require('./object/unset'),\n    'values' : require('./object/values')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/bindAll.js":"var functions = require('./functions');\nvar bind = require('../function/bind');\nvar forEach = require('../array/forEach');\nvar slice = require('../array/slice');\n\n    /**\n     * Binds methods of the object to be run in it's own context.\n     */\n    function bindAll(obj, rest_methodNames){\n        var keys = arguments.length > 1?\n                    slice(arguments, 1) : functions(obj);\n        forEach(keys, function(key){\n            obj[key] = bind(obj[key], obj);\n        });\n    }\n\n    module.exports = bindAll;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/functions.js":"var forIn = require('./forIn');\n\n    /**\n     * return a list of all enumerable properties that have function values\n     */\n    function functions(obj){\n        var keys = [];\n        forIn(obj, function(val, key){\n            if (typeof val === 'function'){\n                keys.push(key);\n            }\n        });\n        return keys.sort();\n    }\n\n    module.exports = functions;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/function/bind.js":"var slice = require('../array/slice');\n\n    /**\n     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.\n     * @param {Function} fn  Function.\n     * @param {object} context   Execution context.\n     * @param {rest} args    Arguments (0...n arguments).\n     * @return {Function} Wrapped Function.\n     */\n    function bind(fn, context, args){\n        var argsArr = slice(arguments, 2); //curried args\n        return function(){\n            return fn.apply(context, argsArr.concat(slice(arguments)));\n        };\n    }\n\n    module.exports = bind;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/slice.js":"\n\n    /**\n     * Create slice of source array or array-like object\n     */\n    function slice(arr, start, end){\n        var len = arr.length;\n\n        if (start == null) {\n            start = 0;\n        } else if (start < 0) {\n            start = Math.max(len + start, 0);\n        } else {\n            start = Math.min(start, len);\n        }\n\n        if (end == null) {\n            end = len;\n        } else if (end < 0) {\n            end = Math.max(len + end, 0);\n        } else {\n            end = Math.min(end, len);\n        }\n\n        var result = [];\n        while (start < end) {\n            result.push(arr[start++]);\n        }\n\n        return result;\n    }\n\n    module.exports = slice;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/forEach.js":"\n\n    /**\n     * Array forEach\n     */\n    function forEach(arr, callback, thisObj) {\n        if (arr == null) {\n            return;\n        }\n        var i = -1,\n            len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if ( callback.call(thisObj, arr[i], i, arr) === false ) {\n                break;\n            }\n        }\n    }\n\n    module.exports = forEach;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/contains.js":"var some = require('./some');\n\n    /**\n     * Check if object contains value\n     */\n    function contains(obj, needle) {\n        return some(obj, function(val) {\n            return (val === needle);\n        });\n    }\n    module.exports = contains;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/some.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object some\n     */\n    function some(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result = false;\n        forOwn(obj, function(val, key) {\n            if (callback(val, key, obj)) {\n                result = true;\n                return false; // break\n            }\n        });\n        return result;\n    }\n\n    module.exports = some;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/deepFillIn.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /**\n     * Deeply copy missing properties in the target from the defaults.\n     */\n    function deepFillIn(target, defaults){\n        var i = 0,\n            n = arguments.length,\n            obj;\n\n        while(++i < n) {\n            obj = arguments[i];\n            if (obj) {\n                // jshint loopfunc: true\n                forOwn(obj, function(newValue, key) {\n                    var curValue = target[key];\n                    if (curValue == null) {\n                        target[key] = newValue;\n                    } else if (isPlainObject(curValue) &&\n                               isPlainObject(newValue)) {\n                        deepFillIn(curValue, newValue);\n                    }\n                });\n            }\n        }\n\n        return target;\n    }\n\n    module.exports = deepFillIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/deepMixIn.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /**\n     * Mixes objects into the target object, recursively mixing existing child\n     * objects.\n     */\n    function deepMixIn(target, objects) {\n        var i = 0,\n            n = arguments.length,\n            obj;\n\n        while(++i < n){\n            obj = arguments[i];\n            if (obj) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n\n        return target;\n    }\n\n    function copyProp(val, key) {\n        var existing = this[key];\n        if (isPlainObject(val) && isPlainObject(existing)) {\n            deepMixIn(existing, val);\n        } else {\n            this[key] = val;\n        }\n    }\n\n    module.exports = deepMixIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/fillIn.js":"var forEach = require('../array/forEach');\nvar slice = require('../array/slice');\nvar forOwn = require('./forOwn');\n\n    /**\n     * Copy missing properties in the obj from the defaults.\n     */\n    function fillIn(obj, var_defaults){\n        forEach(slice(arguments, 1), function(base){\n            forOwn(base, function(val, key){\n                if (obj[key] == null) {\n                    obj[key] = val;\n                }\n            });\n        });\n        return obj;\n    }\n\n    module.exports = fillIn;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/filter.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Creates a new object with all the properties where the callback returns\n     * true.\n     */\n    function filterValues(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var output = {};\n        forOwn(obj, function(value, key, obj) {\n            if (callback(value, key, obj)) {\n                output[key] = value;\n            }\n        });\n\n        return output;\n    }\n    module.exports = filterValues;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/find.js":"var some = require('./some');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Returns first item that matches criteria\n     */\n    function find(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var result;\n        some(obj, function(value, key, obj) {\n            if (callback(value, key, obj)) {\n                result = value;\n                return true; //break\n            }\n        });\n        return result;\n    }\n\n    module.exports = find;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/flatten.js":"var forOwn = require('./forOwn');\nvar isPlainObject = require('../lang/isPlainObject');\n\n    /*\n     * Helper function to flatten to a destination object.\n     * Used to remove the need to create intermediate objects while flattening.\n     */\n    function flattenTo(obj, result, prefix, level) {\n        forOwn(obj, function (value, key) {\n            var nestedPrefix = prefix ? prefix + '.' + key : key;\n\n            if (level !== 0 && isPlainObject(value)) {\n                flattenTo(value, result, nestedPrefix, level - 1);\n            } else {\n                result[nestedPrefix] = value;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Recursively flattens an object.\n     * A new object containing all the elements is returned.\n     * If level is specified, it will only flatten up to that level.\n     */\n    function flatten(obj, level) {\n        if (obj == null) {\n            return {};\n        }\n\n        level = level == null ? -1 : level;\n        return flattenTo(obj, {}, '', level);\n    }\n\n    module.exports = flatten;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/get.js":"var isPrimitive = require('../lang/isPrimitive');\n\n    /**\n     * get \"nested\" object property\n     */\n    function get(obj, prop){\n        var parts = prop.split('.'),\n            last = parts.pop();\n\n        while (prop = parts.shift()) {\n            obj = obj[prop];\n            if (obj == null) return;\n        }\n\n        return obj[last];\n    }\n\n    module.exports = get;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/has.js":"var get = require('./get');\n\n    var UNDEF;\n\n    /**\n     * Check if object has nested property.\n     */\n    function has(obj, prop){\n        return get(obj, prop) !== UNDEF;\n    }\n\n    module.exports = has;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/keys.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object keys\n     */\n     var keys = Object.keys || function (obj) {\n            var keys = [];\n            forOwn(obj, function(val, key){\n                keys.push(key);\n            });\n            return keys;\n        };\n\n    module.exports = keys;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/map.js":"var forOwn = require('./forOwn');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Creates a new object where all the values are the result of calling\n     * `callback`.\n     */\n    function mapValues(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var output = {};\n        forOwn(obj, function(val, key, obj) {\n            output[key] = callback(val, key, obj);\n        });\n\n        return output;\n    }\n    module.exports = mapValues;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/matches.js":"var forOwn = require('./forOwn');\n\n    /**\n     * checks if a object contains all given properties/values\n     */\n    function matches(target, props){\n        // can't use \"object/every\" because of circular dependency\n        var result = true;\n        forOwn(props, function(val, key){\n            if (target[key] !== val) {\n                // break loop at first difference\n                return (result = false);\n            }\n        });\n        return result;\n    }\n\n    module.exports = matches;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/max.js":"var arrMax = require('../array/max');\nvar values = require('./values');\n\n    /**\n     * Returns maximum value inside object.\n     */\n    function max(obj, compareFn) {\n        return arrMax(values(obj), compareFn);\n    }\n\n    module.exports = max;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/max.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Return maximum value inside array\n     */\n    function max(arr, iterator, thisObj){\n        if (arr == null || !arr.length) {\n            return Infinity;\n        } else if (arr.length && !iterator) {\n            return Math.max.apply(Math, arr);\n        } else {\n            iterator = makeIterator(iterator, thisObj);\n            var result,\n                compare = -Infinity,\n                value,\n                temp;\n\n            var i = -1, len = arr.length;\n            while (++i < len) {\n                value = arr[i];\n                temp = iterator(value, i, arr);\n                if (temp > compare) {\n                    compare = temp;\n                    result = value;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    module.exports = max;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/values.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object values\n     */\n    function values(obj) {\n        var vals = [];\n        forOwn(obj, function(val, key){\n            vals.push(val);\n        });\n        return vals;\n    }\n\n    module.exports = values;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/merge.js":"var hasOwn = require('./hasOwn');\nvar deepClone = require('../lang/deepClone');\nvar isObject = require('../lang/isObject');\n\n    /**\n     * Deep merge objects.\n     */\n    function merge() {\n        var i = 1,\n            key, val, obj, target;\n\n        // make sure we don't modify source element and it's properties\n        // objects are passed by reference\n        target = deepClone( arguments[0] );\n\n        while (obj = arguments[i++]) {\n            for (key in obj) {\n                if ( ! hasOwn(obj, key) ) {\n                    continue;\n                }\n\n                val = obj[key];\n\n                if ( isObject(val) && isObject(target[key]) ){\n                    // inception, deep merge objects\n                    target[key] = merge(target[key], val);\n                } else {\n                    // make sure arrays, regexp, date, objects are cloned\n                    target[key] = deepClone(val);\n                }\n\n            }\n        }\n\n        return target;\n    }\n\n    module.exports = merge;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/min.js":"var arrMin = require('../array/min');\nvar values = require('./values');\n\n    /**\n     * Returns minimum value inside object.\n     */\n    function min(obj, iterator) {\n        return arrMin(values(obj), iterator);\n    }\n\n    module.exports = min;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/min.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Return minimum value inside array\n     */\n    function min(arr, iterator, thisObj){\n        if (arr == null || !arr.length) {\n            return -Infinity;\n        } else if (arr.length && !iterator) {\n            return Math.min.apply(Math, arr);\n        } else {\n            iterator = makeIterator(iterator, thisObj);\n            var result,\n                compare = Infinity,\n                value,\n                temp;\n\n            var i = -1, len = arr.length;\n            while (++i < len) {\n                value = arr[i];\n                temp = iterator(value, i, arr);\n                if (temp < compare) {\n                    compare = temp;\n                    result = value;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    module.exports = min;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/namespace.js":"var forEach = require('../array/forEach');\n\n    /**\n     * Create nested object if non-existent\n     */\n    function namespace(obj, path){\n        if (!path) return obj;\n        forEach(path.split('.'), function(key){\n            if (!obj[key]) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        });\n        return obj;\n    }\n\n    module.exports = namespace;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/omit.js":"var slice = require('../array/slice');\nvar contains = require('../array/contains');\n\n    /**\n     * Return a copy of the object, filtered to only contain properties except the blacklisted keys.\n     */\n    function omit(obj, var_keys){\n        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),\n            out = {};\n\n        for (var property in obj) {\n            if (obj.hasOwnProperty(property) && !contains(keys, property)) {\n                out[property] = obj[property];\n            }\n        }\n        return out;\n    }\n\n    module.exports = omit;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/contains.js":"var indexOf = require('./indexOf');\n\n    /**\n     * If array contains values.\n     */\n    function contains(arr, val) {\n        return indexOf(arr, val) !== -1;\n    }\n    module.exports = contains;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/indexOf.js":"\n\n    /**\n     * Array.indexOf\n     */\n    function indexOf(arr, item, fromIndex) {\n        fromIndex = fromIndex || 0;\n        if (arr == null) {\n            return -1;\n        }\n\n        var len = arr.length,\n            i = fromIndex < 0 ? len + fromIndex : fromIndex;\n        while (i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if (arr[i] === item) {\n                return i;\n            }\n\n            i++;\n        }\n\n        return -1;\n    }\n\n    module.exports = indexOf;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/pick.js":"var slice = require('../array/slice');\n\n    /**\n     * Return a copy of the object, filtered to only have values for the whitelisted keys.\n     */\n    function pick(obj, var_keys){\n        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),\n            out = {},\n            i = 0, key;\n        while (key = keys[i++]) {\n            out[key] = obj[key];\n        }\n        return out;\n    }\n\n    module.exports = pick;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/pluck.js":"var map = require('./map');\nvar prop = require('../function/prop');\n\n    /**\n     * Extract a list of property values.\n     */\n    function pluck(obj, propName){\n        return map(obj, prop(propName));\n    }\n\n    module.exports = pluck;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/reduce.js":"var forOwn = require('./forOwn');\nvar size = require('./size');\n\n    /**\n     * Object reduce\n     */\n    function reduce(obj, callback, memo, thisObj) {\n        var initial = arguments.length > 2;\n\n        if (!size(obj) && !initial) {\n            throw new Error('reduce of empty object with no initial value');\n        }\n\n        forOwn(obj, function(value, key, list) {\n            if (!initial) {\n                memo = value;\n                initial = true;\n            }\n            else {\n                memo = callback.call(thisObj, memo, value, key, list);\n            }\n        });\n\n        return memo;\n    }\n\n    module.exports = reduce;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/size.js":"var forOwn = require('./forOwn');\n\n    /**\n     * Get object size\n     */\n    function size(obj) {\n        var count = 0;\n        forOwn(obj, function(){\n            count++;\n        });\n        return count;\n    }\n\n    module.exports = size;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/reject.js":"var filter = require('./filter');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Object reject\n     */\n    function reject(obj, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        return filter(obj, function(value, index, obj) {\n            return !callback(value, index, obj);\n        }, thisObj);\n    }\n\n    module.exports = reject;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/result.js":"var isFunction = require('../lang/isFunction');\n\n    function result(obj, prop) {\n        var property = obj[prop];\n\n        if(property === undefined) {\n            return;\n        }\n\n        return isFunction(property) ? property.call(obj) : property;\n    }\n\n    module.exports = result;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/set.js":"var namespace = require('./namespace');\n\n    /**\n     * set \"nested\" object property\n     */\n    function set(obj, prop, val){\n        var parts = (/^(.+)\\.(.+)$/).exec(prop);\n        if (parts){\n            namespace(obj, parts[1])[parts[2]] = val;\n        } else {\n            obj[prop] = val;\n        }\n    }\n\n    module.exports = set;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/object/unset.js":"var has = require('./has');\n\n    /**\n     * Unset object property.\n     */\n    function unset(obj, prop){\n        if (has(obj, prop)) {\n            var parts = prop.split('.'),\n                last = parts.pop();\n            while (prop = parts.shift()) {\n                obj = obj[prop];\n            }\n            return (delete obj[last]);\n\n        } else {\n            // if property doesn't exist treat as deleted\n            return true;\n        }\n    }\n\n    module.exports = unset;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/util/rc.js":"var path = require('path');\nvar fs = require('graceful-fs');\nvar optimist = require('optimist');\nvar osenv = require('osenv');\nvar object = require('mout/object');\nvar string = require('mout/string');\nvar paths = require('./paths');\nvar defaults = require('./defaults');\n\nvar win = process.platform === 'win32';\nvar home = osenv.home();\n\nfunction rc(name, cwd, argv) {\n    var argvConfig;\n\n    argv = argv || optimist.argv;\n\n    // Parse --config.foo=false\n    argvConfig = object.map(argv.config || {}, function (value) {\n        return value === 'false' ? false : value;\n    });\n\n    // If we have specified a cwd then use this as the base for getting config.\n    cwd = argvConfig.cwd ? argvConfig.cwd : cwd;\n\n    if (cwd) {\n        return object.deepMixIn.apply(null, [\n            {},\n            defaults,\n            { cwd: cwd },\n            win ? {} : json(path.join('/etc', name + 'rc')),\n            !home ? {} : json(path.join(home, '.' + name + 'rc')),\n            json(path.join(paths.config, name + 'rc')),\n            json(find('.' + name + 'rc', cwd)),\n            env('npm_package_config_' + name + '_'),\n            env(name + '_'),\n            argvConfig\n        ]);\n    } else {\n        return object.deepMixIn.apply(null, [\n            {},\n            defaults,\n            win ? {} : json(path.join('/etc', name + 'rc')),\n            !home ? {} : json(path.join(home, '.' + name + 'rc')),\n            json(path.join(paths.config, name + 'rc')),\n            env('npm_package_config_' + name + '_'),\n            env(name + '_'),\n            argvConfig\n        ]);\n    }\n}\n\nfunction parse(content, file) {\n    var error;\n\n    if (!content.trim().length) {\n        return {};\n    }\n\n    try {\n        return JSON.parse(content);\n    } catch (e) {\n        if (file) {\n            error = new Error('Unable to parse ' + file + ': ' + e.message);\n        } else {\n            error = new Error('Unable to parse rc config: ' + e.message);\n        }\n\n        error.details = content;\n        error.code = 'EMALFORMED';\n        throw error;\n    }\n}\n\nfunction json(file) {\n    var content = {};\n    if (!Array.isArray(file)) {\n        try {\n            content = fs.readFileSync(file).toString();\n        } catch (err) {\n            return null;\n        }\n\n        return parse(content, file);\n    } else {\n        // This is multiple json files\n        file.forEach(function(filename) {\n            if (fs.statSync(filename).isDirectory()) {\n                var error;\n                error = new Error(filename + ' should not be a directory');\n                error.code = 'EFILEISDIR';\n                throw error;\n            }\n            var json = fs.readFileSync(filename).toString();\n            json = parse(json, filename);\n            content = object.merge(content, json);\n        });\n\n        return content;\n    }\n}\n\nfunction env(prefix) {\n    var obj = {};\n    var prefixLength = prefix.length;\n\n    prefix = prefix.toLowerCase();\n\n    object.forOwn(process.env, function (value, key) {\n        key = key.toLowerCase();\n\n        if (string.startsWith(key, prefix)) {\n            var parsedKey = key\n                           .substr(prefixLength)\n                           .replace(/__/g, '.')   // __ is used for nesting\n                           .replace(/_/g, '-');   // _ is used as a - separator\n\n            //use a convention patern to accept array from process.env\n            //e.g. export bower_registry__search='[\"http://abc.com\",\"http://def.com\"]'\n            var match = /\\[([^\\]]*)\\]/g.exec(value);\n            var targetValue;\n            if (!match || match.length === 0) {\n                targetValue = value;\n            } else {\n                targetValue = match[1].split(',')\n                    .map(function(m) {\n                        return m.trim();\n                    });\n            }\n            object.set(obj, parsedKey, targetValue);\n        }\n    });\n\n    return obj;\n}\n\nfunction find(filename, dir) {\n    var files = [];\n\n    var walk = function (filename, dir) {\n        var file = path.join(dir, filename);\n        var parent = path.dirname(dir);\n\n        if (fs.existsSync(file)) {\n            files.push(file);\n        }\n\n        if (parent !== dir) {\n            walk(filename, parent);\n        }\n    };\n\n    walk(filename, dir);\n    files.reverse();\n    return files;\n}\n\nmodule.exports = rc;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/graceful-fs/graceful-fs.js":"var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(require('./fs.js'))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {\n  module.exports = patch(fs)\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close =\nfs.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync =\nfs.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n  ReadStream.prototype.open = ReadStream$open\n\n  var fs$WriteStream = fs.WriteStream\n  WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n  WriteStream.prototype.open = WriteStream$open\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/graceful-fs/polyfills.js":"var fs = require('./fs.js')\nvar constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (process.platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs$rename(from, to, CB);\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n}\n\nfunction patchLchmod (fs) {\n  fs.lchmod = function (path, mode, callback) {\n    fs.open( path\n           , constants.O_WRONLY | constants.O_SYMLINK\n           , mode\n           , function (err, fd) {\n      if (err) {\n        if (callback) callback(err)\n        return\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function (err) {\n        fs.close(fd, function(err2) {\n          if (callback) callback(err || err2)\n        })\n      })\n    })\n  }\n\n  fs.lchmodSync = function (path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var threw = true\n    var ret\n    try {\n      ret = fs.fchmodSync(fd, mode)\n      threw = false\n    } finally {\n      if (threw) {\n        try {\n          fs.closeSync(fd)\n        } catch (er) {}\n      } else {\n        fs.closeSync(fd)\n      }\n    }\n    return ret\n  }\n}\n\nfunction patchLutimes (fs) {\n  if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n    fs.lutimes = function (path, at, mt, cb) {\n      fs.open(path, constants.O_SYMLINK, function (er, fd) {\n        if (er) {\n          if (cb) cb(er)\n          return\n        }\n        fs.futimes(fd, at, mt, function (er) {\n          fs.close(fd, function (er2) {\n            if (cb) cb(er || er2)\n          })\n        })\n      })\n    }\n\n    fs.lutimesSync = function (path, at, mt) {\n      var fd = fs.openSync(path, constants.O_SYMLINK)\n      var ret\n      var threw = true\n      try {\n        ret = fs.futimesSync(fd, at, mt)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n\n  } else {\n    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n    fs.lutimesSync = function () {}\n  }\n}\n\nfunction chmodFix (orig) {\n  if (!orig) return orig\n  return function (target, mode, cb) {\n    return orig.call(fs, target, mode, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chmodFixSync (orig) {\n  if (!orig) return orig\n  return function (target, mode) {\n    try {\n      return orig.call(fs, target, mode)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction chownFix (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid, cb) {\n    return orig.call(fs, target, uid, gid, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chownFixSync (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid) {\n    try {\n      return orig.call(fs, target, uid, gid)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction statFix (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target, cb) {\n    return orig.call(fs, target, function (er, stats) {\n      if (!stats) return cb.apply(this, arguments)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction statFixSync (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target) {\n    var stats = orig.call(fs, target)\n    if (stats.uid < 0) stats.uid += 0x100000000\n    if (stats.gid < 0) stats.gid += 0x100000000\n    return stats;\n  }\n}\n\n// ENOSYS means that the fs doesn't support the op. Just ignore\n// that, because it doesn't matter.\n//\n// if there's no getuid, or if getuid() is something other\n// than 0, and the error is EINVAL or EPERM, then just ignore\n// it.\n//\n// This specific case is a silent failure in cp, install, tar,\n// and most other unix tools that manage permissions.\n//\n// When running as root, or if other types of errors are\n// encountered, then it's strict.\nfunction chownErOk (er) {\n  if (!er)\n    return true\n\n  if (er.code === \"ENOSYS\")\n    return true\n\n  var nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n      return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/graceful-fs/fs.js":"'use strict'\n\nvar fs = require('fs')\n\nmodule.exports = clone(fs)\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/graceful-fs/legacy-streams.js":"var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/optimist/index.js":"var path = require('path');\nvar minimist = require('minimist');\nvar wordwrap = require('wordwrap');\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n        require('optimist')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n        require('optimist').argv\n    to get a parsed version of process.argv.\n*/\n\nvar inst = Argv(process.argv.slice(2));\nObject.keys(inst).forEach(function (key) {\n    Argv[key] = typeof inst[key] == 'function'\n        ? inst[key].bind(inst)\n        : inst[key];\n});\n\nvar exports = module.exports = Argv;\nfunction Argv (processArgs, cwd) {\n    var self = {};\n    if (!cwd) cwd = process.cwd();\n    \n    self.$0 = process.argv\n        .slice(0,2)\n        .map(function (x) {\n            var b = rebase(cwd, x);\n            return x.match(/^\\//) && b.length < x.length\n                ? b : x\n        })\n        .join(' ')\n    ;\n    \n    if (process.env._ != undefined && process.argv[1] == process.env._) {\n        self.$0 = process.env._.replace(\n            path.dirname(process.execPath) + '/', ''\n        );\n    }\n    \n    var options = {\n        boolean: [],\n        string: [],\n        alias: {},\n        default: []\n    };\n    \n    self.boolean = function (bools) {\n        options.boolean.push.apply(options.boolean, [].concat(bools));\n        return self;\n    };\n    \n    self.string = function (strings) {\n        options.string.push.apply(options.string, [].concat(strings));\n        return self;\n    };\n    \n    self.default = function (key, value) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.default(k, key[k]);\n            });\n        }\n        else {\n            options.default[key] = value;\n        }\n        return self;\n    };\n    \n    self.alias = function (x, y) {\n        if (typeof x === 'object') {\n            Object.keys(x).forEach(function (key) {\n                self.alias(key, x[key]);\n            });\n        }\n        else {\n            options.alias[x] = (options.alias[x] || []).concat(y);\n        }\n        return self;\n    };\n    \n    var demanded = {};\n    self.demand = function (keys) {\n        if (typeof keys == 'number') {\n            if (!demanded._) demanded._ = 0;\n            demanded._ += keys;\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach(function (key) {\n                self.demand(key);\n            });\n        }\n        else {\n            demanded[keys] = true;\n        }\n        \n        return self;\n    };\n    \n    var usage;\n    self.usage = function (msg, opts) {\n        if (!opts && typeof msg === 'object') {\n            opts = msg;\n            msg = null;\n        }\n        \n        usage = msg;\n        \n        if (opts) self.options(opts);\n        \n        return self;\n    };\n    \n    function fail (msg) {\n        self.showHelp();\n        if (msg) console.error(msg);\n        process.exit(1);\n    }\n    \n    var checks = [];\n    self.check = function (f) {\n        checks.push(f);\n        return self;\n    };\n    \n    var descriptions = {};\n    self.describe = function (key, desc) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.describe(k, key[k]);\n            });\n        }\n        else {\n            descriptions[key] = desc;\n        }\n        return self;\n    };\n    \n    self.parse = function (args) {\n        return parseArgs(args);\n    };\n    \n    self.option = self.options = function (key, opt) {\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(function (k) {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (opt.alias) self.alias(key, opt.alias);\n            if (opt.demand) self.demand(key);\n            if (typeof opt.default !== 'undefined') {\n                self.default(key, opt.default);\n            }\n            \n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n            }\n            \n            var desc = opt.describe || opt.description || opt.desc;\n            if (desc) {\n                self.describe(key, desc);\n            }\n        }\n        \n        return self;\n    };\n    \n    var wrap = null;\n    self.wrap = function (cols) {\n        wrap = cols;\n        return self;\n    };\n    \n    self.showHelp = function (fn) {\n        if (!fn) fn = console.error;\n        fn(self.help());\n    };\n    \n    self.help = function () {\n        var keys = Object.keys(\n            Object.keys(descriptions)\n            .concat(Object.keys(demanded))\n            .concat(Object.keys(options.default))\n            .reduce(function (acc, key) {\n                if (key !== '_') acc[key] = true;\n                return acc;\n            }, {})\n        );\n        \n        var help = keys.length ? [ 'Options:' ] : [];\n        \n        if (usage) {\n            help.unshift(usage.replace(/\\$0/g, self.$0), '');\n        }\n        \n        var switches = keys.reduce(function (acc, key) {\n            acc[key] = [ key ].concat(options.alias[key] || [])\n                .map(function (sw) {\n                    return (sw.length > 1 ? '--' : '-') + sw\n                })\n                .join(', ')\n            ;\n            return acc;\n        }, {});\n        \n        var switchlen = longest(Object.keys(switches).map(function (s) {\n            return switches[s] || '';\n        }));\n        \n        var desclen = longest(Object.keys(descriptions).map(function (d) { \n            return descriptions[d] || '';\n        }));\n        \n        keys.forEach(function (key) {\n            var kswitch = switches[key];\n            var desc = descriptions[key] || '';\n            \n            if (wrap) {\n                desc = wordwrap(switchlen + 4, wrap)(desc)\n                    .slice(switchlen + 4)\n                ;\n            }\n            \n            var spadding = new Array(\n                Math.max(switchlen - kswitch.length + 3, 0)\n            ).join(' ');\n            \n            var dpadding = new Array(\n                Math.max(desclen - desc.length + 1, 0)\n            ).join(' ');\n            \n            var type = null;\n            \n            if (options.boolean[key]) type = '[boolean]';\n            if (options.string[key]) type = '[string]';\n            \n            if (!wrap && dpadding.length > 0) {\n                desc += dpadding;\n            }\n            \n            var prelude = '  ' + kswitch + spadding;\n            var extra = [\n                type,\n                demanded[key]\n                    ? '[required]'\n                    : null\n                ,\n                options.default[key] !== undefined\n                    ? '[default: ' + JSON.stringify(options.default[key]) + ']'\n                    : null\n                ,\n            ].filter(Boolean).join('  ');\n            \n            var body = [ desc, extra ].filter(Boolean).join('  ');\n            \n            if (wrap) {\n                var dlines = desc.split('\\n');\n                var dlen = dlines.slice(-1)[0].length\n                    + (dlines.length === 1 ? prelude.length : 0)\n                \n                body = desc + (dlen + extra.length > wrap - 2\n                    ? '\\n'\n                        + new Array(wrap - extra.length + 1).join(' ')\n                        + extra\n                    : new Array(wrap - extra.length - dlen + 1).join(' ')\n                        + extra\n                );\n            }\n            \n            help.push(prelude + body);\n        });\n        \n        help.push('');\n        return help.join('\\n');\n    };\n    \n    Object.defineProperty(self, 'argv', {\n        get : function () { return parseArgs(processArgs) },\n        enumerable : true,\n    });\n    \n    function parseArgs (args) {\n        var argv = minimist(args, options);\n        argv.$0 = self.$0;\n        \n        if (demanded._ && argv._.length < demanded._) {\n            fail('Not enough non-option arguments: got '\n                + argv._.length + ', need at least ' + demanded._\n            );\n        }\n        \n        var missing = [];\n        Object.keys(demanded).forEach(function (key) {\n            if (!argv[key]) missing.push(key);\n        });\n        \n        if (missing.length) {\n            fail('Missing required arguments: ' + missing.join(', '));\n        }\n        \n        checks.forEach(function (f) {\n            try {\n                if (f(argv) === false) {\n                    fail('Argument check failed: ' + f.toString());\n                }\n            }\n            catch (err) {\n                fail(err)\n            }\n        });\n        \n        return argv;\n    }\n    \n    function longest (xs) {\n        return Math.max.apply(\n            null,\n            xs.map(function (x) { return x.length })\n        );\n    }\n    \n    return self;\n};\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase;\nfunction rebase (base, dir) {\n    var ds = path.normalize(dir).split('/').slice(1);\n    var bs = path.normalize(base).split('/').slice(1);\n    \n    for (var i = 0; ds[i] && ds[i] == bs[i]; i++);\n    ds.splice(0, i); bs.splice(0, i);\n    \n    var p = path.normalize(\n        bs.map(function () { return '..' }).concat(ds).join('/')\n    ).replace(/\\/$/,'').replace(/^$/, '.');\n    return p.match(/^[.\\/]/) ? p : './' + p;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/minimist/index.js":"module.exports = function (args, opts) {\n    if (!opts) opts = {};\n    \n    var flags = { bools : {}, strings : {} };\n    \n    [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {\n        flags.bools[key] = true;\n    });\n    \n    var aliases = {};\n    Object.keys(opts.alias || {}).forEach(function (key) {\n        aliases[key] = [].concat(opts.alias[key]);\n        aliases[key].forEach(function (x) {\n            aliases[x] = [key].concat(aliases[key].filter(function (y) {\n                return x !== y;\n            }));\n        });\n    });\n\n    [].concat(opts.string).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n        if (aliases[key]) {\n            flags.strings[aliases[key]] = true;\n        }\n     });\n\n    var defaults = opts['default'] || {};\n    \n    var argv = { _ : [] };\n    Object.keys(flags.bools).forEach(function (key) {\n        setArg(key, defaults[key] === undefined ? false : defaults[key]);\n    });\n    \n    var notFlags = [];\n\n    if (args.indexOf('--') !== -1) {\n        notFlags = args.slice(args.indexOf('--')+1);\n        args = args.slice(0, args.indexOf('--'));\n    }\n\n    function setArg (key, val) {\n        var value = !flags.strings[key] && isNumber(val)\n            ? Number(val) : val\n        ;\n        setKey(argv, key.split('.'), value);\n        \n        (aliases[key] || []).forEach(function (x) {\n            setKey(argv, x.split('.'), value);\n        });\n    }\n    \n    for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        \n        if (/^--.+=/.test(arg)) {\n            // Using [\\s\\S] instead of . because js doesn't support the\n            // 'dotall' regex modifier. See:\n            // http://stackoverflow.com/a/1068308/13216\n            var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n            setArg(m[1], m[2]);\n        }\n        else if (/^--no-.+/.test(arg)) {\n            var key = arg.match(/^--no-(.+)/)[1];\n            setArg(key, false);\n        }\n        else if (/^--.+/.test(arg)) {\n            var key = arg.match(/^--(.+)/)[1];\n            var next = args[i + 1];\n            if (next !== undefined && !/^-/.test(next)\n            && !flags.bools[key]\n            && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                setArg(key, next);\n                i++;\n            }\n            else if (/^(true|false)$/.test(next)) {\n                setArg(key, next === 'true');\n                i++;\n            }\n            else {\n                setArg(key, flags.strings[key] ? '' : true);\n            }\n        }\n        else if (/^-[^-]+/.test(arg)) {\n            var letters = arg.slice(1,-1).split('');\n            \n            var broken = false;\n            for (var j = 0; j < letters.length; j++) {\n                var next = arg.slice(j+2);\n                \n                if (next === '-') {\n                    setArg(letters[j], next)\n                    continue;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j])\n                && /-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n                    setArg(letters[j], next);\n                    broken = true;\n                    break;\n                }\n                \n                if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                    setArg(letters[j], arg.slice(j+2));\n                    broken = true;\n                    break;\n                }\n                else {\n                    setArg(letters[j], flags.strings[letters[j]] ? '' : true);\n                }\n            }\n            \n            var key = arg.slice(-1)[0];\n            if (!broken && key !== '-') {\n                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])\n                && !flags.bools[key]\n                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {\n                    setArg(key, args[i+1]);\n                    i++;\n                }\n                else if (args[i+1] && /true|false/.test(args[i+1])) {\n                    setArg(key, args[i+1] === 'true');\n                    i++;\n                }\n                else {\n                    setArg(key, flags.strings[key] ? '' : true);\n                }\n            }\n        }\n        else {\n            argv._.push(\n                flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n            );\n        }\n    }\n    \n    Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) {\n            setKey(argv, key.split('.'), defaults[key]);\n            \n            (aliases[key] || []).forEach(function (x) {\n                setKey(argv, x.split('.'), defaults[key]);\n            });\n        }\n    });\n    \n    notFlags.forEach(function(key) {\n        argv._.push(key);\n    });\n\n    return argv;\n};\n\nfunction hasKey (obj, keys) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        o = (o[key] || {});\n    });\n\n    var key = keys[keys.length - 1];\n    return key in o;\n}\n\nfunction setKey (obj, keys, value) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        if (o[key] === undefined) o[key] = {};\n        o = o[key];\n    });\n    \n    var key = keys[keys.length - 1];\n    if (o[key] === undefined || typeof o[key] === 'boolean') {\n        o[key] = value;\n    }\n    else if (Array.isArray(o[key])) {\n        o[key].push(value);\n    }\n    else {\n        o[key] = [ o[key], value ];\n    }\n}\n\nfunction isNumber (x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/wordwrap/index.js":"var wordwrap = module.exports = function (start, stop, params) {\n    if (typeof start === 'object') {\n        params = start;\n        start = params.start;\n        stop = params.stop;\n    }\n    \n    if (typeof stop === 'object') {\n        params = stop;\n        start = start || params.start;\n        stop = undefined;\n    }\n    \n    if (!stop) {\n        stop = start;\n        start = 0;\n    }\n    \n    if (!params) params = {};\n    var mode = params.mode || 'soft';\n    var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n    \n    return function (text) {\n        var chunks = text.toString()\n            .split(re)\n            .reduce(function (acc, x) {\n                if (mode === 'hard') {\n                    for (var i = 0; i < x.length; i += stop - start) {\n                        acc.push(x.slice(i, i + stop - start));\n                    }\n                }\n                else acc.push(x)\n                return acc;\n            }, [])\n        ;\n        \n        return chunks.reduce(function (lines, rawChunk) {\n            if (rawChunk === '') return lines;\n            \n            var chunk = rawChunk.replace(/\\t/g, '    ');\n            \n            var i = lines.length - 1;\n            if (lines[i].length + chunk.length > stop) {\n                lines[i] = lines[i].replace(/\\s+$/, '');\n                \n                chunk.split(/\\n/).forEach(function (c) {\n                    lines.push(\n                        new Array(start + 1).join(' ')\n                        + c.replace(/^\\s+/, '')\n                    );\n                });\n            }\n            else if (chunk.match(/\\n/)) {\n                var xs = chunk.split(/\\n/);\n                lines[i] += xs.shift();\n                xs.forEach(function (c) {\n                    lines.push(\n                        new Array(start + 1).join(' ')\n                        + c.replace(/^\\s+/, '')\n                    );\n                });\n            }\n            else {\n                lines[i] += chunk;\n            }\n            \n            return lines;\n        }, [ new Array(start + 1).join(' ') ]).join('\\n');\n    };\n};\n\nwordwrap.soft = wordwrap;\n\nwordwrap.hard = function (start, stop) {\n    return wordwrap(start, stop, { mode : 'hard' });\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/osenv/osenv.js":"var isWindows = process.platform === 'win32'\nvar path = require('path')\nvar exec = require('child_process').exec\nvar osTmpdir = require('os-tmpdir')\nvar osHomedir = require('os-homedir')\n\n// looking up envs is a bit costly.\n// Also, sometimes we want to have a fallback\n// Pass in a callback to wait for the fallback on failures\n// After the first lookup, always returns the same thing.\nfunction memo (key, lookup, fallback) {\n  var fell = false\n  var falling = false\n  exports[key] = function (cb) {\n    var val = lookup()\n    if (!val && !fell && !falling && fallback) {\n      fell = true\n      falling = true\n      exec(fallback, function (er, output, stderr) {\n        falling = false\n        if (er) return // oh well, we tried\n        val = output.trim()\n      })\n    }\n    exports[key] = function (cb) {\n      if (cb) process.nextTick(cb.bind(null, null, val))\n      return val\n    }\n    if (cb && !falling) process.nextTick(cb.bind(null, null, val))\n    return val\n  }\n}\n\nmemo('user', function () {\n  return ( isWindows\n         ? process.env.USERDOMAIN + '\\\\' + process.env.USERNAME\n         : process.env.USER\n         )\n}, 'whoami')\n\nmemo('prompt', function () {\n  return isWindows ? process.env.PROMPT : process.env.PS1\n})\n\nmemo('hostname', function () {\n  return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME\n}, 'hostname')\n\nmemo('tmpdir', function () {\n  return osTmpdir()\n})\n\nmemo('home', function () {\n  return osHomedir()\n})\n\nmemo('path', function () {\n  return (process.env.PATH ||\n          process.env.Path ||\n          process.env.path).split(isWindows ? ';' : ':')\n})\n\nmemo('editor', function () {\n  return process.env.EDITOR ||\n         process.env.VISUAL ||\n         (isWindows ? 'notepad.exe' : 'vi')\n})\n\nmemo('shell', function () {\n  return isWindows ? process.env.ComSpec || 'cmd'\n         : process.env.SHELL || 'bash'\n})\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/os-tmpdir/index.js":"'use strict';\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/os-homedir/index.js":"'use strict';\nvar os = require('os');\n\nfunction homedir() {\n\tvar env = process.env;\n\tvar home = env.HOME;\n\tvar user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;\n\n\tif (process.platform === 'win32') {\n\t\treturn env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;\n\t}\n\n\tif (process.platform === 'darwin') {\n\t\treturn home || (user ? '/Users/' + user : null);\n\t}\n\n\tif (process.platform === 'linux') {\n\t\treturn home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));\n\t}\n\n\treturn home || null;\n}\n\nmodule.exports = typeof os.homedir === 'function' ? os.homedir : homedir;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string.js":"\n\n//automatically generated, do not edit!\n//run `node build` instead\nmodule.exports = {\n    'WHITE_SPACES' : require('./string/WHITE_SPACES'),\n    'camelCase' : require('./string/camelCase'),\n    'contains' : require('./string/contains'),\n    'crop' : require('./string/crop'),\n    'endsWith' : require('./string/endsWith'),\n    'escapeHtml' : require('./string/escapeHtml'),\n    'escapeRegExp' : require('./string/escapeRegExp'),\n    'escapeUnicode' : require('./string/escapeUnicode'),\n    'hyphenate' : require('./string/hyphenate'),\n    'insert' : require('./string/insert'),\n    'interpolate' : require('./string/interpolate'),\n    'lowerCase' : require('./string/lowerCase'),\n    'lpad' : require('./string/lpad'),\n    'ltrim' : require('./string/ltrim'),\n    'makePath' : require('./string/makePath'),\n    'normalizeLineBreaks' : require('./string/normalizeLineBreaks'),\n    'pascalCase' : require('./string/pascalCase'),\n    'properCase' : require('./string/properCase'),\n    'removeNonASCII' : require('./string/removeNonASCII'),\n    'removeNonWord' : require('./string/removeNonWord'),\n    'repeat' : require('./string/repeat'),\n    'replace' : require('./string/replace'),\n    'replaceAccents' : require('./string/replaceAccents'),\n    'rpad' : require('./string/rpad'),\n    'rtrim' : require('./string/rtrim'),\n    'sentenceCase' : require('./string/sentenceCase'),\n    'slugify' : require('./string/slugify'),\n    'startsWith' : require('./string/startsWith'),\n    'stripHtmlTags' : require('./string/stripHtmlTags'),\n    'trim' : require('./string/trim'),\n    'truncate' : require('./string/truncate'),\n    'typecast' : require('./string/typecast'),\n    'unCamelCase' : require('./string/unCamelCase'),\n    'underscore' : require('./string/underscore'),\n    'unescapeHtml' : require('./string/unescapeHtml'),\n    'unescapeUnicode' : require('./string/unescapeUnicode'),\n    'unhyphenate' : require('./string/unhyphenate'),\n    'upperCase' : require('./string/upperCase')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/WHITE_SPACES.js":"\n    /**\n     * Contains all Unicode white-spaces. Taken from\n     * http://en.wikipedia.org/wiki/Whitespace_character.\n     */\n    module.exports = [\n        ' ', '\\n', '\\r', '\\t', '\\f', '\\v', '\\u00A0', '\\u1680', '\\u180E',\n        '\\u2000', '\\u2001', '\\u2002', '\\u2003', '\\u2004', '\\u2005', '\\u2006',\n        '\\u2007', '\\u2008', '\\u2009', '\\u200A', '\\u2028', '\\u2029', '\\u202F',\n        '\\u205F', '\\u3000'\n    ];\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/camelCase.js":"var toString = require('../lang/toString');\nvar replaceAccents = require('./replaceAccents');\nvar removeNonWord = require('./removeNonWord');\nvar upperCase = require('./upperCase');\nvar lowerCase = require('./lowerCase');\n    /**\n    * Convert string to camelCase text.\n    */\n    function camelCase(str){\n        str = toString(str);\n        str = replaceAccents(str);\n        str = removeNonWord(str)\n            .replace(/[\\-_]/g, ' ') //convert all hyphens and underscores to spaces\n            .replace(/\\s[a-z]/g, upperCase) //convert first char of each word to UPPERCASE\n            .replace(/\\s+/g, '') //remove spaces\n            .replace(/^[A-Z]/g, lowerCase); //convert first char to lowercase\n        return str;\n    }\n    module.exports = camelCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/replaceAccents.js":"var toString = require('../lang/toString');\n    /**\n    * Replaces all accented chars with regular ones\n    */\n    function replaceAccents(str){\n        str = toString(str);\n\n        // verifies if the String has accents and replace them\n        if (str.search(/[\\xC0-\\xFF]/g) > -1) {\n            str = str\n                    .replace(/[\\xC0-\\xC5]/g, \"A\")\n                    .replace(/[\\xC6]/g, \"AE\")\n                    .replace(/[\\xC7]/g, \"C\")\n                    .replace(/[\\xC8-\\xCB]/g, \"E\")\n                    .replace(/[\\xCC-\\xCF]/g, \"I\")\n                    .replace(/[\\xD0]/g, \"D\")\n                    .replace(/[\\xD1]/g, \"N\")\n                    .replace(/[\\xD2-\\xD6\\xD8]/g, \"O\")\n                    .replace(/[\\xD9-\\xDC]/g, \"U\")\n                    .replace(/[\\xDD]/g, \"Y\")\n                    .replace(/[\\xDE]/g, \"P\")\n                    .replace(/[\\xE0-\\xE5]/g, \"a\")\n                    .replace(/[\\xE6]/g, \"ae\")\n                    .replace(/[\\xE7]/g, \"c\")\n                    .replace(/[\\xE8-\\xEB]/g, \"e\")\n                    .replace(/[\\xEC-\\xEF]/g, \"i\")\n                    .replace(/[\\xF1]/g, \"n\")\n                    .replace(/[\\xF2-\\xF6\\xF8]/g, \"o\")\n                    .replace(/[\\xF9-\\xFC]/g, \"u\")\n                    .replace(/[\\xFE]/g, \"p\")\n                    .replace(/[\\xFD\\xFF]/g, \"y\");\n        }\n        return str;\n    }\n    module.exports = replaceAccents;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/removeNonWord.js":"var toString = require('../lang/toString');\n    // This pattern is generated by the _build/pattern-removeNonWord.js script\n    var PATTERN = /[^\\x20\\x2D0-9A-Z\\x5Fa-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\xFF]/g;\n\n    /**\n     * Remove non-word chars.\n     */\n    function removeNonWord(str){\n        str = toString(str);\n        return str.replace(PATTERN, '');\n    }\n\n    module.exports = removeNonWord;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/upperCase.js":"var toString = require('../lang/toString');\n    /**\n     * \"Safer\" String.toUpperCase()\n     */\n    function upperCase(str){\n        str = toString(str);\n        return str.toUpperCase();\n    }\n    module.exports = upperCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/lowerCase.js":"var toString = require('../lang/toString');\n    /**\n     * \"Safer\" String.toLowerCase()\n     */\n    function lowerCase(str){\n        str = toString(str);\n        return str.toLowerCase();\n    }\n\n    module.exports = lowerCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/contains.js":"var toString = require('../lang/toString');\n\n    /**\n     * Searches for a given substring\n     */\n    function contains(str, substring, fromIndex){\n        str = toString(str);\n        substring = toString(substring);\n        return str.indexOf(substring, fromIndex) !== -1;\n    }\n\n    module.exports = contains;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/crop.js":"var toString = require('../lang/toString');\nvar truncate = require('./truncate');\n    /**\n     * Truncate string at full words.\n     */\n     function crop(str, maxChars, append) {\n         str = toString(str);\n         return truncate(str, maxChars, append, true);\n     }\n\n     module.exports = crop;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/truncate.js":"var toString = require('../lang/toString');\nvar trim = require('./trim');\n    /**\n     * Limit number of chars.\n     */\n    function truncate(str, maxChars, append, onlyFullWords){\n        str = toString(str);\n        append = append || '...';\n        maxChars = onlyFullWords? maxChars + 1 : maxChars;\n\n        str = trim(str);\n        if(str.length <= maxChars){\n            return str;\n        }\n        str = str.substr(0, maxChars - append.length);\n        //crop at last space or remove trailing whitespace\n        str = onlyFullWords? str.substr(0, str.lastIndexOf(' ')) : trim(str);\n        return str + append;\n    }\n    module.exports = truncate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/trim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\nvar ltrim = require('./ltrim');\nvar rtrim = require('./rtrim');\n    /**\n     * Remove white-spaces from beginning and end of string.\n     */\n    function trim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n        return ltrim(rtrim(str, chars), chars);\n    }\n\n    module.exports = trim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/ltrim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\n    /**\n     * Remove chars from beginning of string.\n     */\n    function ltrim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n\n        var start = 0,\n            len = str.length,\n            charLen = chars.length,\n            found = true,\n            i, c;\n\n        while (found && start < len) {\n            found = false;\n            i = -1;\n            c = str.charAt(start);\n\n            while (++i < charLen) {\n                if (c === chars[i]) {\n                    found = true;\n                    start++;\n                    break;\n                }\n            }\n        }\n\n        return (start >= len) ? '' : str.substr(start, len);\n    }\n\n    module.exports = ltrim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/rtrim.js":"var toString = require('../lang/toString');\nvar WHITE_SPACES = require('./WHITE_SPACES');\n    /**\n     * Remove chars from end of string.\n     */\n    function rtrim(str, chars) {\n        str = toString(str);\n        chars = chars || WHITE_SPACES;\n\n        var end = str.length - 1,\n            charLen = chars.length,\n            found = true,\n            i, c;\n\n        while (found && end >= 0) {\n            found = false;\n            i = -1;\n            c = str.charAt(end);\n\n            while (++i < charLen) {\n                if (c === chars[i]) {\n                    found = true;\n                    end--;\n                    break;\n                }\n            }\n        }\n\n        return (end >= 0) ? str.substring(0, end + 1) : '';\n    }\n\n    module.exports = rtrim;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/endsWith.js":"var toString = require('../lang/toString');\n    /**\n     * Checks if string ends with specified suffix.\n     */\n    function endsWith(str, suffix) {\n        str = toString(str);\n        suffix = toString(suffix);\n\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n\n    module.exports = endsWith;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/escapeHtml.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escapes a string for insertion into HTML.\n     */\n    function escapeHtml(str){\n        str = toString(str)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/'/g, '&#39;')\n            .replace(/\"/g, '&quot;');\n        return str;\n    }\n\n    module.exports = escapeHtml;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/escapeRegExp.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escape RegExp string chars.\n     */\n    function escapeRegExp(str) {\n        return toString(str).replace(/\\W/g,'\\\\$&');\n    }\n\n    module.exports = escapeRegExp;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/escapeUnicode.js":"var toString = require('../lang/toString');\n\n    /**\n     * Escape string into unicode sequences\n     */\n    function escapeUnicode(str, shouldEscapePrintable){\n        str = toString(str);\n        return str.replace(/[\\s\\S]/g, function(ch){\n            // skip printable ASCII chars if we should not escape them\n            if (!shouldEscapePrintable && (/[\\x20-\\x7E]/).test(ch)) {\n                return ch;\n            }\n            // we use \"000\" and slice(-4) for brevity, need to pad zeros,\n            // unicode escape always have 4 chars after \"\\u\"\n            return '\\\\u'+ ('000'+ ch.charCodeAt(0).toString(16)).slice(-4);\n        });\n    }\n\n    module.exports = escapeUnicode;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/hyphenate.js":"var toString = require('../lang/toString');\nvar slugify = require('./slugify');\nvar unCamelCase = require('./unCamelCase');\n    /**\n     * Replaces spaces with hyphens, split camelCase text, remove non-word chars, remove accents and convert to lower case.\n     */\n    function hyphenate(str){\n        str = toString(str);\n        str = unCamelCase(str);\n        return slugify(str, \"-\");\n    }\n\n    module.exports = hyphenate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/slugify.js":"var toString = require('../lang/toString');\nvar replaceAccents = require('./replaceAccents');\nvar removeNonWord = require('./removeNonWord');\nvar trim = require('./trim');\n    /**\n     * Convert to lower case, remove accents, remove non-word chars and\n     * replace spaces with the specified delimeter.\n     * Does not split camelCase text.\n     */\n    function slugify(str, delimeter){\n        str = toString(str);\n\n        if (delimeter == null) {\n            delimeter = \"-\";\n        }\n        str = replaceAccents(str);\n        str = removeNonWord(str);\n        str = trim(str) //should come after removeNonWord\n                .replace(/ +/g, delimeter) //replace spaces with delimeter\n                .toLowerCase();\n        return str;\n    }\n    module.exports = slugify;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/unCamelCase.js":"var toString = require('../lang/toString');\n\n    var CAMEL_CASE_BORDER = /([a-z\\xE0-\\xFF])([A-Z\\xC0\\xDF])/g;\n\n    /**\n     * Add space between camelCase text.\n     */\n    function unCamelCase(str, delimiter){\n        if (delimiter == null) {\n            delimiter = ' ';\n        }\n\n        function join(str, c1, c2) {\n            return c1 + delimiter + c2;\n        }\n\n        str = toString(str);\n        str = str.replace(CAMEL_CASE_BORDER, join);\n        str = str.toLowerCase(); //add space between camelCase text\n        return str;\n    }\n    module.exports = unCamelCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/insert.js":"var clamp = require('../math/clamp');\nvar toString = require('../lang/toString');\n\n    /**\n     * Inserts a string at a given index.\n     */\n    function insert(string, index, partial){\n        string = toString(string);\n\n        if (index < 0) {\n            index = string.length + index;\n        }\n\n        index = clamp(index, 0, string.length);\n\n        return string.substr(0, index) + partial + string.substr(index);\n    }\n\n    module.exports = insert;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/math/clamp.js":"\n    /**\n     * Clamps value inside range.\n     */\n    function clamp(val, min, max){\n        return val < min? min : (val > max? max : val);\n    }\n    module.exports = clamp;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/interpolate.js":"var toString = require('../lang/toString');\nvar get = require('../object/get');\n\n    var stache = /\\{\\{([^\\}]+)\\}\\}/g; //mustache-like\n\n    /**\n     * String interpolation\n     */\n    function interpolate(template, replacements, syntax){\n        template = toString(template);\n        var replaceFn = function(match, prop){\n            return toString( get(replacements, prop) );\n        };\n        return template.replace(syntax || stache, replaceFn);\n    }\n\n    module.exports = interpolate;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/lpad.js":"var toString = require('../lang/toString');\nvar repeat = require('./repeat');\n\n    /**\n     * Pad string with `char` if its' length is smaller than `minLen`\n     */\n    function lpad(str, minLen, ch) {\n        str = toString(str);\n        ch = ch || ' ';\n\n        return (str.length < minLen) ?\n            repeat(ch, minLen - str.length) + str : str;\n    }\n\n    module.exports = lpad;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/repeat.js":"var toString = require('../lang/toString');\nvar toInt = require('../number/toInt');\n\n    /**\n     * Repeat string n times\n     */\n     function repeat(str, n){\n         var result = '';\n         str = toString(str);\n         n = toInt(n);\n        if (n < 1) {\n            return '';\n        }\n        while (n > 0) {\n            if (n % 2) {\n                result += str;\n            }\n            n = Math.floor(n / 2);\n            str += str;\n        }\n        return result;\n     }\n\n     module.exports = repeat;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/number/toInt.js":"\n\n    /**\n     * \"Convert\" value into an 32-bit integer.\n     * Works like `Math.floor` if val > 0 and `Math.ceil` if val < 0.\n     * IMPORTANT: val will wrap at 2^31 and -2^31.\n     * Perf tests: http://jsperf.com/vs-vs-parseint-bitwise-operators/7\n     */\n    function toInt(val){\n        // we do not use lang/toNumber because of perf and also because it\n        // doesn't break the functionality\n        return ~~val;\n    }\n\n    module.exports = toInt;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/makePath.js":"var join = require('../array/join');\nvar slice = require('../array/slice');\n\n    /**\n     * Group arguments as path segments, if any of the args is `null` or an\n     * empty string it will be ignored from resulting path.\n     */\n    function makePath(var_args){\n        var result = join(slice(arguments), '/');\n        // need to disconsider duplicate '/' after protocol (eg: 'http://')\n        return result.replace(/([^:\\/]|^)\\/{2,}/g, '$1/');\n    }\n\n    module.exports = makePath;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/join.js":"var filter = require('./filter');\n\n    function isValidString(val) {\n        return (val != null && val !== '');\n    }\n\n    /**\n     * Joins strings with the specified separator inserted between each value.\n     * Null values and empty strings will be excluded.\n     */\n    function join(items, separator) {\n        separator = separator || '';\n        return filter(items, isValidString).join(separator);\n    }\n\n    module.exports = join;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/array/filter.js":"var makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array filter\n     */\n    function filter(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null) {\n            return results;\n        }\n\n        var i = -1, len = arr.length, value;\n        while (++i < len) {\n            value = arr[i];\n            if (callback(value, i, arr)) {\n                results.push(value);\n            }\n        }\n\n        return results;\n    }\n\n    module.exports = filter;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/normalizeLineBreaks.js":"var toString = require('../lang/toString');\n\n    /**\n     * Convert line-breaks from DOS/MAC to a single standard (UNIX by default)\n     */\n    function normalizeLineBreaks(str, lineEnd) {\n        str = toString(str);\n        lineEnd = lineEnd || '\\n';\n\n        return str\n            .replace(/\\r\\n/g, lineEnd) // DOS\n            .replace(/\\r/g, lineEnd)   // Mac\n            .replace(/\\n/g, lineEnd);  // Unix\n    }\n\n    module.exports = normalizeLineBreaks;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/pascalCase.js":"var toString = require('../lang/toString');\nvar camelCase = require('./camelCase');\nvar upperCase = require('./upperCase');\n    /**\n     * camelCase + UPPERCASE first char\n     */\n    function pascalCase(str){\n        str = toString(str);\n        return camelCase(str).replace(/^[a-z]/, upperCase);\n    }\n\n    module.exports = pascalCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/properCase.js":"var toString = require('../lang/toString');\nvar lowerCase = require('./lowerCase');\nvar upperCase = require('./upperCase');\n    /**\n     * UPPERCASE first char of each word.\n     */\n    function properCase(str){\n        str = toString(str);\n        return lowerCase(str).replace(/^\\w|\\s\\w/g, upperCase);\n    }\n\n    module.exports = properCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/removeNonASCII.js":"var toString = require('../lang/toString');\n    /**\n     * Remove non-printable ASCII chars\n     */\n    function removeNonASCII(str){\n        str = toString(str);\n\n        // Matches non-printable ASCII chars -\n        // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters\n        return str.replace(/[^\\x20-\\x7E]/g, '');\n    }\n\n    module.exports = removeNonASCII;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/replace.js":"var toString = require('../lang/toString');\nvar toArray = require('../lang/toArray');\n\n    /**\n     * Replace string(s) with the replacement(s) in the source.\n     */\n    function replace(str, search, replacements) {\n        str = toString(str);\n        search = toArray(search);\n        replacements = toArray(replacements);\n\n        var searchLength = search.length,\n            replacementsLength = replacements.length;\n\n        if (replacementsLength !== 1 && searchLength !== replacementsLength) {\n            throw new Error('Unequal number of searches and replacements');\n        }\n\n        var i = -1;\n        while (++i < searchLength) {\n            // Use the first replacement for all searches if only one\n            // replacement is provided\n            str = str.replace(\n                search[i],\n                replacements[(replacementsLength === 1) ? 0 : i]);\n        }\n\n        return str;\n    }\n\n    module.exports = replace;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/rpad.js":"var toString = require('../lang/toString');\nvar repeat = require('./repeat');\n\n    /**\n     * Pad string with `char` if its' length is smaller than `minLen`\n     */\n    function rpad(str, minLen, ch) {\n        str = toString(str);\n        ch = ch || ' ';\n        return (str.length < minLen)? str + repeat(ch, minLen - str.length) : str;\n    }\n\n    module.exports = rpad;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/sentenceCase.js":"var toString = require('../lang/toString');\nvar lowerCase = require('./lowerCase');\nvar upperCase = require('./upperCase');\n    /**\n     * UPPERCASE first char of each sentence and lowercase other chars.\n     */\n    function sentenceCase(str){\n        str = toString(str);\n\n        // Replace first char of each sentence (new line or after '.\\s+') to\n        // UPPERCASE\n        return lowerCase(str).replace(/(^\\w)|\\.\\s+(\\w)/gm, upperCase);\n    }\n    module.exports = sentenceCase;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/startsWith.js":"var toString = require('../lang/toString');\n    /**\n     * Checks if string starts with specified prefix.\n     */\n    function startsWith(str, prefix) {\n        str = toString(str);\n        prefix = toString(prefix);\n\n        return str.indexOf(prefix) === 0;\n    }\n\n    module.exports = startsWith;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/stripHtmlTags.js":"var toString = require('../lang/toString');\n    /**\n     * Remove HTML tags from string.\n     */\n    function stripHtmlTags(str){\n        str = toString(str);\n\n        return str.replace(/<[^>]*>/g, '');\n    }\n    module.exports = stripHtmlTags;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/typecast.js":"\n\n    var UNDEF;\n\n    /**\n     * Parses string and convert it into a native value.\n     */\n    function typecast(val) {\n        var r;\n        if ( val === null || val === 'null' ) {\n            r = null;\n        } else if ( val === 'true' ) {\n            r = true;\n        } else if ( val === 'false' ) {\n            r = false;\n        } else if ( val === UNDEF || val === 'undefined' ) {\n            r = UNDEF;\n        } else if ( val === '' || isNaN(val) ) {\n            //isNaN('') returns false\n            r = val;\n        } else {\n            //parseFloat(null || '') returns NaN\n            r = parseFloat(val);\n        }\n        return r;\n    }\n\n    module.exports = typecast;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/underscore.js":"var toString = require('../lang/toString');\nvar slugify = require('./slugify');\nvar unCamelCase = require('./unCamelCase');\n    /**\n     * Replaces spaces with underscores, split camelCase text, remove non-word chars, remove accents and convert to lower case.\n     */\n    function underscore(str){\n        str = toString(str);\n        str = unCamelCase(str);\n        return slugify(str, \"_\");\n    }\n    module.exports = underscore;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/unescapeHtml.js":"var toString = require('../lang/toString');\n\n    /**\n     * Unescapes HTML special chars\n     */\n    function unescapeHtml(str){\n        str = toString(str)\n            .replace(/&amp;/g , '&')\n            .replace(/&lt;/g  , '<')\n            .replace(/&gt;/g  , '>')\n            .replace(/&#0*39;/g , \"'\")\n            .replace(/&quot;/g, '\"');\n        return str;\n    }\n\n    module.exports = unescapeHtml;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/unescapeUnicode.js":"var toString = require('../lang/toString');\n\n    /**\n     * Unescape unicode char sequences\n     */\n    function unescapeUnicode(str){\n        str = toString(str);\n        return str.replace(/\\\\u[0-9a-f]{4}/g, function(ch){\n            var code = parseInt(ch.slice(2), 16);\n            return String.fromCharCode(code);\n        });\n    }\n\n    module.exports = unescapeUnicode;\n\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/node_modules/mout/string/unhyphenate.js":"var toString = require('../lang/toString');\n    /**\n     * Replaces hyphens with spaces. (only hyphens between word chars)\n     */\n    function unhyphenate(str){\n        str = toString(str);\n        return str.replace(/(\\w)(-)(\\w)/g, '$1 $3');\n    }\n    module.exports = unhyphenate;\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/util/paths.js":"var os = require('os');\nvar path = require('path');\nvar osenv = require('osenv');\nvar crypto = require('crypto');\n\nfunction generateFakeUser() {\n    var uid = process.pid + '-' + Date.now() + '-' + Math.floor(Math.random() * 1000000);\n    return crypto.createHash('md5').update(uid).digest('hex');\n}\n\n// Assume XDG defaults\n// See: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\nvar paths = {\n    config: process.env.XDG_CONFIG_HOME,\n    data: process.env.XDG_DATA_HOME,\n    cache: process.env.XDG_CACHE_HOME\n};\n\n// Guess some needed properties based on the user OS\nvar user = (osenv.user() || generateFakeUser()).replace(/\\\\/g, '-');\nvar tmp = path.join(os.tmpdir ? os.tmpdir() : os.tmpDir(), user);\nvar home = osenv.home();\nvar base;\n\n// Fallbacks for windows\nif (process.platform === 'win32') {\n    base = path.resolve(process.env.LOCALAPPDATA || home || tmp);\n    base = path.join(base, 'bower');\n\n    paths.config = paths.config || path.join(base, 'config');\n    paths.data = paths.data || path.join(base, 'data');\n    paths.cache = paths.cache || path.join(base, 'cache');\n// Fallbacks for other operating systems\n} else {\n    base = path.resolve(home || tmp);\n\n    paths.config = paths.config || path.join(base, '.config/bower');\n    paths.data = paths.data || path.join(base, '.local/share/bower');\n    paths.cache = paths.cache || path.join(base, '.cache/bower');\n}\n\npaths.tmp = path.resolve(path.join(tmp, 'bower'));\n\nmodule.exports = paths;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/util/defaults.js":"var path = require('path');\nvar paths = require('./paths');\n\n// Guess proxy defined in the env\nvar proxy = process.env.HTTP_PROXY\n    || process.env.http_proxy\n    || null;\n\nvar httpsProxy = process.env.HTTPS_PROXY\n    || process.env.https_proxy\n    || proxy;\n\nvar noProxy = process.env.NO_PROXY\n    || process.env.no_proxy;\n\n// Use a well known user agent (in this case, curl) when using a proxy,\n// to avoid potential filtering on many corporate proxies with blank or unknown agents\nvar userAgent = !proxy && !httpsProxy\n    ? 'node/' + process.version + ' ' + process.platform + ' ' + process.arch\n    : 'curl/7.21.4 (universal-apple-darwin11.0) libcurl/7.21.4 OpenSSL/0.9.8r zlib/1.2.5';\n\nvar defaults = {\n    'directory': 'bower_components',\n    'registry': 'https://bower.herokuapp.com',\n    'shorthand-resolver': 'https://github.com/{{owner}}/{{package}}.git',\n    'tmp': paths.tmp,\n    'proxy': proxy,\n    'https-proxy': httpsProxy,\n    'no-proxy': noProxy,\n    'timeout': 30000,\n    'ca': { search: [] },\n    'strict-ssl': true,\n    'user-agent': userAgent,\n    'color': true,\n    'interactive': null,\n    'storage': {\n        packages: path.join(paths.cache, 'packages'),\n        links: path.join(paths.data, 'links'),\n        completion: path.join(paths.data, 'completion'),\n        registry: path.join(paths.cache, 'registry'),\n        empty: path.join(paths.data, 'empty')  // Empty dir, used in GIT_TEMPLATE_DIR among others\n    }\n};\n\nmodule.exports = defaults;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/util/expand.js":"var object = require('mout/object');\nvar lang = require('mout/lang');\nvar string = require('mout/string');\n\nfunction camelCase(config) {\n    var camelCased = {};\n\n    // Camel case\n    object.forOwn(config, function (value, key) {\n        // Ignore null values\n        if (value == null) {\n            return;\n        }\n\n        key = string.camelCase(key.replace(/_/g, '-'));\n        camelCased[key] = lang.isPlainObject(value) ? camelCase(value) : value;\n    });\n\n    return camelCased;\n}\n\n// Function to replace ${VAR} - style variables\n//  with values set in the environment\n// This function expects to be passed a string\nfunction doEnvReplaceStr (f) {\n\n  // Un-tildify\n  var untildify = require('untildify');\n  f = untildify(f);\n\n  // replace any ${ENV} values with the appropriate environ.\n  var envExpr = /(\\\\*)\\$\\{([^}]+)\\}/g;\n  return f.replace(envExpr, function (orig, esc, name) {\n    esc = esc.length && esc.length % 2;\n    if (esc) return orig;\n    if (undefined === process.env[name]) {\n      throw new Error('Environment variable used in .bowerrc is not defined: ' + orig);\n    }\n\n    return process.env[name];\n});\n}\n\nfunction envReplace(config) {\n    var envReplaced = {};\n\n    object.forOwn(config, function (value, key) {\n\n        // Ignore null values\n        if (value == null) {\n            return;\n        }\n\n        // Ignore 'scripts'\n        // These hooks run within the shell\n        // environment variable expansion is not required\n        if ( key === 'scripts' && lang.isPlainObject(value) ){\n            envReplaced[key] = value;\n            return;\n        }\n\n        // Perform variable replacements based on var type\n        if ( lang.isPlainObject(value) ) {\n            envReplaced[key] = envReplace(value);\n        }\n        else if ( lang.isString(value) ) {\n            envReplaced[key] = doEnvReplaceStr(value);\n        }\n        else {\n            envReplaced[key] = value;\n        }\n    });\n\n    return envReplaced;\n}\n\nfunction expand(config) {\n    config = camelCase(config);\n    config = envReplace(config);\n\n    if (typeof config.registry === 'string') {\n        config.registry = {\n            default: config.registry,\n            search: [config.registry],\n            register: config.registry,\n            publish: config.registry\n        };\n    } else if (typeof config.registry === 'object') {\n        config.registry.default = config.registry.default || 'https://bower.herokuapp.com';\n\n        config.registry = {\n            default: config.registry.default,\n            search: config.registry.search || config.registry.default,\n            register: config.registry.register || config.registry.default,\n            publish: config.registry.publish || config.registry.default\n        };\n\n        if (config.registry.search && !Array.isArray(config.registry.search)) {\n            config.registry.search = [config.registry.search];\n        }\n    }\n\n    // CA\n    if (typeof config.ca === 'string') {\n        config.ca = {\n            default: config.ca,\n            search: [config.ca],\n            register: config.ca,\n            publish: config.ca\n        };\n    } else if (typeof config.ca === 'object') {\n        if (config.ca.search && !Array.isArray(config.ca.search)) {\n            config.ca.search = [config.ca.search];\n        }\n\n        if (config.ca.default) {\n            config.ca.search = config.ca.search || config.ca.default;\n            config.ca.register = config.ca.register || config.ca.default;\n            config.ca.publish = config.ca.publish || config.ca.default;\n        }\n    }\n\n    return config;\n}\n\nmodule.exports = expand;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/bower-config/lib/util/proxy.js":"// EnvProxy uses the proxy vaiables passed to it in set and sets the\n// process.env uppercase proxy variables to them with the ability\n// to restore the original values later\nvar EnvProxy = function() {\n  this.restoreFrom = {};\n};\n\nEnvProxy.prototype.set = function (config) {\n  this.config = config;\n\n  // Override environment defaults if proxy config options are set\n  // This will make requests.js follow the proxies in config\n  if (Object.prototype.hasOwnProperty.call(config, 'noProxy')) {\n    this.restoreFrom.NO_PROXY = process.env.NO_PROXY;\n    this.restoreFrom.no_proxy = process.env.no_proxy;\n    delete process.env.no_proxy;\n    process.env.NO_PROXY = config.noProxy;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'proxy')) {\n    this.restoreFrom.HTTP_PROXY = process.env.HTTP_PROXY;\n    this.restoreFrom.http_proxy = process.env.http_proxy;\n    delete process.env.http_proxy;\n    process.env.HTTP_PROXY = config.proxy;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'httpsProxy')) {\n    this.restoreFrom.HTTPS_PROXY = process.env.HTTPS_PROXY;\n    this.restoreFrom.https_proxy = process.env.https_proxy;\n    delete process.env.https_proxy;\n    process.env.HTTPS_PROXY = config.httpsProxy;\n  }\n};\n\nEnvProxy.prototype.restore = function () {\n  if (Object.prototype.hasOwnProperty.call(this.config, 'noProxy')) {\n    if (this.restoreFrom.NO_PROXY !== undefined) {\n      process.env.NO_PROXY = this.restoreFrom.NO_PROXY;\n    } else {\n      delete process.env.NO_PROXY;\n    }\n\n    if (this.restoreFrom.no_proxy !== undefined) {\n      process.env.no_proxy = this.restoreFrom.no_proxy;\n    } else {\n      delete process.env.no_proxy;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(this.config, 'proxy')) {\n    if (this.restoreFrom.HTTP_PROXY !== undefined) {\n      process.env.HTTP_PROXY = this.restoreFrom.HTTP_PROXY;\n    } else {\n      delete process.env.HTTP_PROXY;\n    }\n\n    if (this.restoreFrom.http_proxy !== undefined) {\n      process.env.http_proxy = this.restoreFrom.http_proxy;\n    } else {\n      delete process.env.http_proxy;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(this.config, 'httpsProxy')) {\n    if (this.restoreFrom.HTTPS_PROXY !== undefined) {\n      process.env.HTTPS_PROXY = this.restoreFrom.HTTPS_PROXY;\n    } else {\n      delete process.env.HTTPS_PROXY;\n    }\n\n    if (this.restoreFrom.https_proxy !== undefined) {\n      process.env.https_proxy = this.restoreFrom.https_proxy;\n    } else {\n      delete process.env.https_proxy;\n    }\n  }\n};\n\nmodule.exports = EnvProxy;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/configstore/index.js":"'use strict';\nvar path = require('path');\nvar fs = require('graceful-fs');\nvar osenv = require('osenv');\nvar assign = require('object-assign');\nvar mkdirp = require('mkdirp');\nvar uuid = require('uuid');\nvar xdgBasedir = require('xdg-basedir');\nvar osTmpdir = require('os-tmpdir');\nvar writeFileAtomic = require('write-file-atomic');\nvar dotProp = require('dot-prop');\n\nvar user = (osenv.user() || uuid.v4()).replace(/\\\\/g, '');\nvar configDir = xdgBasedir.config || path.join(osTmpdir(), user, '.config');\nvar permissionError = 'You don\\'t have access to this file.';\nvar defaultPathMode = parseInt('0700', 8);\nvar writeFileOptions = {mode: parseInt('0600', 8)};\n\nfunction Configstore(id, defaults, opts) {\n\topts = opts || {};\n\n\tvar pathPrefix = opts.globalConfigPath ?\n\t\tpath.join(id, 'config.json') :\n\t\tpath.join('configstore', id + '.json');\n\n\tthis.path = path.join(configDir, pathPrefix);\n\n\tthis.all = assign({}, defaults || {}, this.all || {});\n}\n\nConfigstore.prototype = Object.create(Object.prototype, {\n\tall: {\n\t\tget: function () {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(fs.readFileSync(this.path, 'utf8'));\n\t\t\t} catch (err) {\n\t\t\t\t// create dir if it doesn't exist\n\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\tmkdirp.sync(path.dirname(this.path), defaultPathMode);\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\t// improve the message of permission errors\n\t\t\t\tif (err.code === 'EACCES') {\n\t\t\t\t\terr.message = err.message + '\\n' + permissionError + '\\n';\n\t\t\t\t}\n\n\t\t\t\t// empty the file if it encounters invalid JSON\n\t\t\t\tif (err.name === 'SyntaxError') {\n\t\t\t\t\twriteFileAtomic.sync(this.path, '', writeFileOptions);\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t},\n\t\tset: function (val) {\n\t\t\ttry {\n\t\t\t\t// make sure the folder exists as it\n\t\t\t\t// could have been deleted in the meantime\n\t\t\t\tmkdirp.sync(path.dirname(this.path), defaultPathMode);\n\n\t\t\t\twriteFileAtomic.sync(this.path, JSON.stringify(val, null, '\\t'), writeFileOptions);\n\t\t\t} catch (err) {\n\t\t\t\t// improve the message of permission errors\n\t\t\t\tif (err.code === 'EACCES') {\n\t\t\t\t\terr.message = err.message + '\\n' + permissionError + '\\n';\n\t\t\t\t}\n\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t},\n\tsize: {\n\t\tget: function () {\n\t\t\treturn Object.keys(this.all || {}).length;\n\t\t}\n\t}\n});\n\nConfigstore.prototype.get = function (key) {\n\treturn dotProp.get(this.all, key);\n};\n\nConfigstore.prototype.set = function (key, val) {\n\tvar config = this.all;\n\tif (arguments.length === 1) {\n\t\tObject.keys(key).forEach(function (k) {\n\t\t\tdotProp.set(config, k, key[k]);\n\t\t});\n\t} else {\n\t\tdotProp.set(config, key, val);\n\t}\n\tthis.all = config;\n};\n\nConfigstore.prototype.has = function (key) {\n\treturn dotProp.has(this.all, key);\n};\n\nConfigstore.prototype.delete = Configstore.prototype.del = function (key) {\n\tvar config = this.all;\n\tdotProp.delete(config, key);\n\tthis.all = config;\n};\n\nConfigstore.prototype.clear = function () {\n\tthis.all = {};\n};\n\nmodule.exports = Configstore;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/configstore/node_modules/object-assign/index.js":"'use strict';\n/* eslint-disable no-unused-vars */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (e) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/uuid/uuid.js":"//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/uuid/rng.js":"var rb = require('crypto').randomBytes;\nmodule.exports = function() {\n  return rb(16);\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/xdg-basedir/index.js":"'use strict';\nvar path = require('path');\nvar osHomedir = require('os-homedir');\nvar home = osHomedir();\nvar env = process.env;\n\nexports.data = env.XDG_DATA_HOME ||\n\t(home ? path.join(home, '.local', 'share') : null);\n\nexports.config = env.XDG_CONFIG_HOME ||\n\t(home ? path.join(home, '.config') : null);\n\nexports.cache = env.XDG_CACHE_HOME || (home ? path.join(home, '.cache') : null);\n\nexports.runtime = env.XDG_RUNTIME_DIR || null;\n\nexports.dataDirs = (env.XDG_DATA_DIRS || '/usr/local/share/:/usr/share/').split(':');\n\nif (exports.data) {\n\texports.dataDirs.unshift(exports.data);\n}\n\nexports.configDirs = (env.XDG_CONFIG_DIRS || '/etc/xdg').split(':');\n\nif (exports.config) {\n\texports.configDirs.unshift(exports.config);\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/write-file-atomic/index.js":"'use strict'\nvar fs = require('graceful-fs')\nvar chain = require('slide').chain\nvar MurmurHash3 = require('imurmurhash')\nvar extend = Object.assign || require('util')._extend\n\nfunction murmurhex () {\n  var hash = new MurmurHash3()\n  for (var ii = 0; ii < arguments.length; ++ii) hash.hash('' + arguments[ii])\n  return hash.result()\n}\nvar invocations = 0\nvar getTmpname = function (filename) {\n  return filename + '.' + murmurhex(__filename, process.pid, ++invocations)\n}\n\nmodule.exports = function writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = null\n  }\n  if (!options) options = {}\n  var tmpfile = getTmpname(filename)\n\n  if (options.mode && options.chmod) {\n    return thenWriteFile()\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      options = extend({}, options)\n      if (!err && stats && !options.mode) {\n        options.mode = stats.mode\n      }\n      if (!err && stats && !options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n      return thenWriteFile()\n    })\n  }\n\n  function thenWriteFile () {\n    chain([\n      [fs, fs.writeFile, tmpfile, data, options.encoding || 'utf8'],\n      options.mode && [fs, fs.chmod, tmpfile, options.mode],\n      options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],\n      [fs, fs.rename, tmpfile, filename]\n    ], function (err) {\n      err ? fs.unlink(tmpfile, function () { callback(err) })\n        : callback()\n    })\n  }\n}\n\nmodule.exports.sync = function writeFileSync (filename, data, options) {\n  if (!options) options = {}\n  var tmpfile = getTmpname(filename)\n\n  try {\n    if (!options.mode || !options.chmod) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename)\n\n        options = extend({}, options)\n        if (!options.mode) {\n          options.mode = stats.mode\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n\n    fs.writeFileSync(tmpfile, data, options.encoding || 'utf8')\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n  } catch (err) {\n    try { fs.unlinkSync(tmpfile) } catch (e) {}\n    throw err\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/slide/lib/slide.js":"exports.asyncMap = require(\"./async-map\")\nexports.bindActor = require(\"./bind-actor\")\nexports.chain = require(\"./chain\")\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/slide/lib/async-map.js":"\n/*\nusage:\n\n// do something to a list of things\nasyncMap(myListOfStuff, function (thing, cb) { doSomething(thing.foo, cb) }, cb)\n// do more than one thing to each item\nasyncMap(list, fooFn, barFn, cb)\n\n*/\n\nmodule.exports = asyncMap\n\nfunction asyncMap () {\n  var steps = Array.prototype.slice.call(arguments)\n    , list = steps.shift() || []\n    , cb_ = steps.pop()\n  if (typeof cb_ !== \"function\") throw new Error(\n    \"No callback provided to asyncMap\")\n  if (!list) return cb_(null, [])\n  if (!Array.isArray(list)) list = [list]\n  var n = steps.length\n    , data = [] // 2d array\n    , errState = null\n    , l = list.length\n    , a = l * n\n  if (!a) return cb_(null, [])\n  function cb (er) {\n    if (er && !errState) errState = er\n\n    var argLen = arguments.length\n    for (var i = 1; i < argLen; i ++) if (arguments[i] !== undefined) {\n      data[i - 1] = (data[i - 1] || []).concat(arguments[i])\n    }\n    // see if any new things have been added.\n    if (list.length > l) {\n      var newList = list.slice(l)\n      a += (list.length - l) * n\n      l = list.length\n      process.nextTick(function () {\n        newList.forEach(function (ar) {\n          steps.forEach(function (fn) { fn(ar, cb) })\n        })\n      })\n    }\n\n    if (--a === 0) cb_.apply(null, [errState].concat(data))\n  }\n  // expect the supplied cb function to be called\n  // \"n\" times for each thing in the array.\n  list.forEach(function (ar) {\n    steps.forEach(function (fn) { fn(ar, cb) })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/slide/lib/bind-actor.js":"module.exports = bindActor\nfunction bindActor () {\n  var args = \n        Array.prototype.slice.call\n        (arguments) // jswtf.\n    , obj = null\n    , fn\n  if (typeof args[0] === \"object\") {\n    obj = args.shift()\n    fn = args.shift()\n    if (typeof fn === \"string\")\n      fn = obj[ fn ]\n  } else fn = args.shift()\n  return function (cb) {\n    fn.apply(obj, args.concat(cb)) }\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/slide/lib/chain.js":"module.exports = chain\nvar bindActor = require(\"./bind-actor.js\")\nchain.first = {} ; chain.last = {}\nfunction chain (things, cb) {\n  var res = []\n  ;(function LOOP (i, len) {\n    if (i >= len) return cb(null,res)\n    if (Array.isArray(things[i]))\n      things[i] = bindActor.apply(null,\n        things[i].map(function(i){\n          return (i===chain.first) ? res[0]\n           : (i===chain.last)\n             ? res[res.length - 1] : i }))\n    if (!things[i]) return LOOP(i + 1, len)\n    things[i](function (er, data) {\n      if (er) return cb(er, res)\n      if (data !== undefined) res = res.concat(data)\n      LOOP(i + 1, len)\n    })\n  })(0, things.length) }\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/imurmurhash/imurmurhash.js":"/**\n * @preserve\n * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)\n *\n * @author <a href=\"mailto:jensyt@gmail.com\">Jens Taylor</a>\n * @see http://github.com/homebrewing/brauhaus-diff\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n */\n(function(){\n    var cache;\n\n    // Call this function without `new` to use the cached object (good for\n    // single-threaded environments), or with `new` to create a new object.\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @param {number} seed An optional positive integer\n    // @return {object} A MurmurHash3 object for incremental hashing\n    function MurmurHash3(key, seed) {\n        var m = this instanceof MurmurHash3 ? this : cache;\n        m.reset(seed)\n        if (typeof key === 'string' && key.length > 0) {\n            m.hash(key);\n        }\n\n        if (m !== this) {\n            return m;\n        }\n    };\n\n    // Incrementally add a string to this hash\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @return {object} this\n    MurmurHash3.prototype.hash = function(key) {\n        var h1, k1, i, top, len;\n\n        len = key.length;\n        this.len += len;\n\n        k1 = this.k1;\n        i = 0;\n        switch (this.rem) {\n            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;\n            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;\n            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;\n            case 3:\n                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;\n                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;\n        }\n\n        this.rem = (len + this.rem) & 3; // & 3 is same as % 4\n        len -= this.rem;\n        if (len > 0) {\n            h1 = this.h1;\n            while (1) {\n                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n                k1 = (k1 << 15) | (k1 >>> 17);\n                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n\n                h1 ^= k1;\n                h1 = (h1 << 13) | (h1 >>> 19);\n                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;\n\n                if (i >= len) {\n                    break;\n                }\n\n                k1 = ((key.charCodeAt(i++) & 0xffff)) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 8) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 16);\n                top = key.charCodeAt(i++);\n                k1 ^= ((top & 0xff) << 24) ^\n                      ((top & 0xff00) >> 8);\n            }\n\n            k1 = 0;\n            switch (this.rem) {\n                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;\n                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;\n                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);\n            }\n\n            this.h1 = h1;\n        }\n\n        this.k1 = k1;\n        return this;\n    };\n\n    // Get the result of this hash\n    //\n    // @return {number} The 32-bit hash\n    MurmurHash3.prototype.result = function() {\n        var k1, h1;\n        \n        k1 = this.k1;\n        h1 = this.h1;\n\n        if (k1 > 0) {\n            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n            h1 ^= k1;\n        }\n\n        h1 ^= this.len;\n\n        h1 ^= h1 >>> 16;\n        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;\n        h1 ^= h1 >>> 13;\n        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;\n        h1 ^= h1 >>> 16;\n\n        return h1 >>> 0;\n    };\n\n    // Reset the hash object for reuse\n    //\n    // @param {number} seed An optional positive integer\n    MurmurHash3.prototype.reset = function(seed) {\n        this.h1 = typeof seed === 'number' ? seed : 0;\n        this.rem = this.k1 = this.len = 0;\n        return this;\n    };\n\n    // A cached object to use. This can be safely used if you're in a single-\n    // threaded environment, otherwise you need to create new hashes to use.\n    cache = new MurmurHash3();\n\n    if (typeof(module) != 'undefined') {\n        module.exports = MurmurHash3;\n    } else {\n        this.MurmurHash3 = MurmurHash3;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/dot-prop/index.js":"'use strict';\nvar isObj = require('is-obj');\n\nmodule.exports.get = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn obj;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, pathArr[i]) || Object.getOwnPropertyDescriptor(Object.prototype, pathArr[i]);\n\t\tif (descriptor && !descriptor.enumerable) {\n\t\t\treturn;\n\t\t}\n\n\t\tobj = obj[pathArr[i]];\n\n\t\tif (obj === undefined || obj === null) {\n\t\t\t// `obj` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t// if this is not the last bit of the path, and\n\t\t\t// if it did't return `undefined`\n\t\t\t// it would return `null` if `obj` is `null`\n\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined` not `null`\n\t\t\tif (i !== pathArr.length - 1) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports.set = function (obj, path, value) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\tif (!isObj(obj[p])) {\n\t\t\tobj[p] = {};\n\t\t}\n\n\t\tif (i === pathArr.length - 1) {\n\t\t\tobj[p] = value;\n\t\t}\n\n\t\tobj = obj[p];\n\t}\n};\n\nmodule.exports.delete = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\tif (i === pathArr.length - 1) {\n\t\t\tdelete obj[p];\n\t\t\treturn;\n\t\t}\n\n\t\tobj = obj[p];\n\t}\n};\n\nmodule.exports.has = function (obj, path) {\n\tif (!isObj(obj) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tvar pathArr = getPathSegments(path);\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tobj = obj[pathArr[i]];\n\n\t\tif (obj === undefined) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nfunction getPathSegments(path) {\n\tvar pathArr = path.split('.');\n\tvar parts = [];\n\n\tfor (var i = 0; i < pathArr.length; i++) {\n\t\tvar p = pathArr[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArr[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArr[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\treturn parts;\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/is-obj/index.js":"'use strict';\nmodule.exports = function (x) {\n\tvar type = typeof x;\n\treturn x !== null && (type === 'object' || type === 'function');\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/version.js":"var findup = require('findup-sync');\n\nmodule.exports = require(findup('package.json', { cwd: __dirname })).version;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/findup-sync/lib/findup-sync.js":"/*\n * findup-sync\n * https://github.com/cowboy/node-findup-sync\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n\n'use strict';\n\n// Nodejs libs.\nvar path = require('path');\n\n// External libs.\nvar glob = require('glob');\n\n// Search for a filename in the given directory or all parent directories.\nmodule.exports = function(patterns, options) {\n  // Normalize patterns to an array.\n  if (!Array.isArray(patterns)) { patterns = [patterns]; }\n  // Create globOptions so that it can be modified without mutating the\n  // original object.\n  var globOptions = Object.create(options || {});\n  globOptions.maxDepth = 1;\n  globOptions.cwd = path.resolve(globOptions.cwd || '.');\n\n  var files, lastpath;\n  do {\n    // Search for files matching patterns.\n    files = patterns.map(function(pattern) {\n      return glob.sync(pattern, globOptions);\n    }).reduce(function(a, b) {\n      return a.concat(b);\n    }).filter(function(entry, index, arr) {\n      return index === arr.indexOf(entry);\n    });\n    // Return file if found.\n    if (files.length > 0) {\n      return path.resolve(path.join(globOptions.cwd, files[0]));\n    }\n    // Go up a directory.\n    lastpath = globOptions.cwd;\n    globOptions.cwd = path.resolve(globOptions.cwd, '..');\n  // If parentpath is the same as basedir, we can't go any higher.\n  } while (globOptions.cwd !== lastpath);\n\n  // No files were found!\n  return null;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/findup-sync/node_modules/glob/glob.js":"// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nglob.hasMagic = function (pattern, options_) {\n  var options = util._extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  var n = this.minimatch.set.length\n  this._processing = 0\n  this.matches = new Array(n)\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    fs.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (this.matches[index][e])\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = this._makeAbs(e)\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  if (this.mark)\n    e = this._mark(e)\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er)\n      return cb()\n\n    var isSym = lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/minimatch/minimatch.js":"module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/brace-expansion/index.js":"var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = /^(.*,)+(.+)?$/.test(m.body);\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/concat-map/index.js":"module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/balanced-match/index.js":"module.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/inherits/inherits.js":"try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/path-is-absolute/index.js":"'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/findup-sync/node_modules/glob/sync.js":"module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = fs.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this.matches[index][e] = true\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  var abs = this._makeAbs(e)\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[this._makeAbs(e)]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    // lstat failed, doesn't exist\n    return null\n  }\n\n  var isSym = lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this.matches[index][prefix] = true\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      return false\n    }\n\n    if (lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/findup-sync/node_modules/glob/common.js":"exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern)\n  }\n\n  return {\n    matcher: new Minimatch(pattern),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = options.cwd\n    self.changedCwd = path.resolve(options.cwd) !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  self.nomount = !!options.nomount\n\n  // disable comments and negation unless the user explicitly\n  // passes in false as the option.\n  options.nonegate = options.nonegate === false ? false : true\n  options.nocomment = options.nocomment === false ? false : true\n  deprecationWarning(options)\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\n// TODO(isaacs): remove entirely in v6\n// exported to reset in tests\nexports.deprecationWarned\nfunction deprecationWarning(options) {\n  if (!options.nonegate || !options.nocomment) {\n    if (process.noDeprecation !== true && !exports.deprecationWarned) {\n      var msg = 'glob WARNING: comments and negation will be disabled in v6'\n      if (process.throwDeprecation)\n        throw new Error(msg)\n      else if (process.traceDeprecation)\n        console.trace(msg)\n      else\n        console.error(msg)\n\n      exports.deprecationWarned = true\n    }\n  }\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        return !(/\\/$/.test(e))\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/inflight/inflight.js":"var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/wrappy/wrappy.js":"// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/once/once.js":"var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/util/abbreviations.js":"var abbrev = require('abbrev');\nvar mout = require('mout');\n\nfunction expandNames(obj, prefix, stack) {\n    prefix = prefix || '';\n    stack = stack || [];\n\n    mout.object.forOwn(obj, function (value, name) {\n        name = prefix + name;\n\n        stack.push(name);\n\n        if (typeof value === 'object' && !value.line) {\n            expandNames(value, name + ' ', stack);\n        }\n    });\n\n    return stack;\n}\n\nmodule.exports = function (commands) {\n    var abbreviations = abbrev(expandNames(commands));\n\n    abbreviations.i = 'install';\n    abbreviations.rm = 'uninstall';\n    abbreviations.unlink = 'uninstall';\n    abbreviations.ls = 'list';\n\n    return abbreviations;\n};\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/abbrev/abbrev.js":"\nmodule.exports = exports = abbrev.abbrev = abbrev\n\nabbrev.monkeyPatch = monkeyPatch\n\nfunction monkeyPatch () {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function () { return abbrev(this) },\n    enumerable: false, configurable: true, writable: true\n  })\n\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function () { return abbrev(Object.keys(this)) },\n    enumerable: false, configurable: true, writable: true\n  })\n}\n\nfunction abbrev (list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0)\n  }\n  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i])\n  }\n\n  // sort them lexicographically, so that they're next to their nearest kin\n  args = args.sort(lexSort)\n\n  // walk through each, seeing how much it has in common with the next and previous\n  var abbrevs = {}\n    , prev = \"\"\n  for (var i = 0, l = args.length ; i < l ; i ++) {\n    var current = args[i]\n      , next = args[i + 1] || \"\"\n      , nextMatches = true\n      , prevMatches = true\n    if (current === next) continue\n    for (var j = 0, cl = current.length ; j < cl ; j ++) {\n      var curChar = current.charAt(j)\n      nextMatches = nextMatches && curChar === next.charAt(j)\n      prevMatches = prevMatches && curChar === prev.charAt(j)\n      if (!nextMatches && !prevMatches) {\n        j ++\n        break\n      }\n    }\n    prev = current\n    if (j === cl) {\n      abbrevs[current] = current\n      continue\n    }\n    for (var a = current.substr(0, j) ; j <= cl ; j ++) {\n      abbrevs[a] = current\n      a += current.charAt(j)\n    }\n  }\n  return abbrevs\n}\n\nfunction lexSort (a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n","/home/travis/build/npmtest/node-npmtest-bower/bower/lib/node_modules/untildify/index.js":"'use strict';\nvar osHomedir = require('os-homedir');\nvar home = osHomedir();\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn home ? str.replace(/^~($|\\/|\\\\)/, home + '$1') : str;\n};\n"}